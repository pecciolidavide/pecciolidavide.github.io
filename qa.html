<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Domande e Risposte</title>
    <link href="https://fonts.googleapis.com/css?family=Fira+Code:300,600|Fira+Sans:300,600&display=swap&subset=latin-ext" rel="stylesheet"/>
    <link rel="stylesheet" type="text/css" href="https://use.fontawesome.com/releases/v5.10.1/css/all.css"/>
    <link rel="stylesheet" type="text/css" href="assets/css/vs.css"/>
    <style>
      html {
	  font-family: "Fira Sans", sans-serif;
	  font-size: 16pt;
	  background-image: url('assets/images/background.png');
	  background-attachment: fixed;
	  margin: 0;
	  padding: 0;
      }

      pre, code {
	  font-family: "Fira Code", monospace;
      }

      body {
	  max-width: 900px;
	  margin: 1ex auto;
	  counter-reset: chapter;
	  background-color: white;
	  padding: 16px 32px;
	  box-shadow: 0 0 4px 4px #A0A0A0;
	  border-radius: 8px;
      }

      h1 {
	  font-weight: 300;
	  color: white;
	  background: #004080;
	  text-align: center;
	  margin: -16px -32px 16px -32px;
	  padding: 16px 32px;
	  border-radius: 8px 8px 0 0;
      }

      h2 {
	  /* margin: 0 -32px; */
	  padding: 4px 0 0 0;
      }

      i.fas, i.far {
	  font-size: smaller;
	  margin: 0 0.25ex;
      }

      a, a:visited {
	  color: teal;
	  text-decoration: none;
      }

      a:hover {
	  color: white;
	  background-color: teal;
	  border-radius: 0.5ex;
	  margin: 0.1ex -0.25ex;
	  padding: 0.1ex 0.25ex;
	  text-decoration: none;
      }

      .legend {
	  display: inline-block;
	  width: 300px;
	  padding: 0 8px 0 0;
	  float: right;
	  font-size: small;
	  background: orange;
	  border-radius: 3px;
      }

      .footer {
	  display: inline-block;
	  font-size: small;
      }
    </style>
  </head>
  <body>
    <div id="root" class="index">
      <h1 id="domande--risposte">DOMANDE &amp; RISPOSTE</h1>

<h2 id="organizzazione">Organizzazione</h2>

<h3 id="il-link--alle-soluzioni-degli-esercizi-non-funziona-perché">Il link <i class="far fa-cog"></i> alle soluzioni degli esercizi non funziona. Perché?</h3>

<p>Le soluzioni si trovano nell’archivio che contiene le slide e questo
stesso documento. Se il link indicato dal simbolo <i class="far fa-cog"></i> fornito nell’<a href="index.html">indice</a> non funziona è perché
il browser non è in grado di aprire le cartelle come se fossero
pagine Web. In tal caso, è sufficiente aprire la cartella
<code class="language-plaintext highlighter-rouge">assets/code</code> (o <code class="language-plaintext highlighter-rouge">assets\code</code> se si utilizza il sistema operativo
Windows) all’interno dell’archivio. In questa cartella sono presenti
altre sotto-cartelle, una per ogni blocco di slide, con il codice
sorgente discusso e le soluzioni degli esercizi.</p>

<h2 id="funzioni">Funzioni</h2>

<h3 id="nel-codice-vedo-espressioni-contenenti-punti-interrogativi-cosa-sono">Nel codice vedo espressioni contenenti punti interrogativi. Cosa sono?</h3>

<p>In C++, un’espressione della forma</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  B ? E₁ : E₂
</code></pre></div></div>

<p>dove <code class="language-plaintext highlighter-rouge">B</code>, <code class="language-plaintext highlighter-rouge">E₁</code> ed <code class="language-plaintext highlighter-rouge">E₂</code> sono espressioni è una cosiddetta
<strong>espressione ternaria</strong> o <strong>espressione condizionale</strong> ed il suo
valore è determinato da quello di <code class="language-plaintext highlighter-rouge">B</code>, che deve essere
un’espressione booleana: se <code class="language-plaintext highlighter-rouge">B</code> è vera (cioè il suo valore è <code class="language-plaintext highlighter-rouge">true</code>)
allora il valore dell’intera espressione coincide con il valore di
<code class="language-plaintext highlighter-rouge">E₁</code>. Se <code class="language-plaintext highlighter-rouge">B</code> è falsa (cioè il suo valore è <code class="language-plaintext highlighter-rouge">false</code>) allora il valore
dell’intera espressione coincide con quello di <code class="language-plaintext highlighter-rouge">E₂</code>.</p>

<p>L’espressione ternaria svolge un’analoga funzione del comando
<code class="language-plaintext highlighter-rouge">if</code>-<code class="language-plaintext highlighter-rouge">else</code>, con la differenza che, trattandosi di un’espressione e
non di un comando, produce un valore come risultato. Come semplice
esempio, la funzione <code class="language-plaintext highlighter-rouge">max</code> che calcola il massimo di numeri interi
può essere scritta con <code class="language-plaintext highlighter-rouge">if</code>-<code class="language-plaintext highlighter-rouge">else</code> nel seguente modo</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">max</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>e con un’espressione ternaria nel seguente modo:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">max</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="che-cosè-il-prefisso-std-anteposto-al-nome-di-classioggettifunzioni">Che cos’è il prefisso <code class="language-plaintext highlighter-rouge">std::</code> anteposto al nome di classi/oggetti/funzioni?</h3>

<p>I programmi C++ di medie/grandi dimensioni sono suddivisi in
<em>namespace</em> (letteralmente “spazi di nomi”). Ogni namespace
racchiude definizioni di tipi, classi e funzioni. Questa
suddivisione fa sì che possano coesistere, nello stesso programma,
entità diverse ma con lo stesso nome, purché queste entità risiedano
in namespace differenti. Normalmente, infatti, non è possibile avere
più definizioni diverse con lo stesso nome, ad eccezione dei casi di
<em>overloading</em>, che comunque si applicano solo a
funzioni/metodi/operatori ed hanno un significato ben preciso.</p>

<p>Per fare riferimento all’entità <code class="language-plaintext highlighter-rouge">x</code> che si trova nel namespace <code class="language-plaintext highlighter-rouge">ns</code>,
la sintassi generale è <code class="language-plaintext highlighter-rouge">ns::x</code>. Quando importiamo definizioni dalla
libreria standard, per esempio con</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></code></pre></div></div>

<p>queste definizioni risiedono tutte nel namespace <code class="language-plaintext highlighter-rouge">std</code>, e dunque per
farvi riferimento si usa una sintassi del tipo <code class="language-plaintext highlighter-rouge">std::cout</code>,
<code class="language-plaintext highlighter-rouge">std::min</code>, ecc. In alternativa, è possibile “aprire” il namespace
all’inizio di un programma con la direttiva</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</code></pre></div></div>

<p>in modo tale che tutte le definizioni nel namespace <code class="language-plaintext highlighter-rouge">std</code> diventano
visibili nel programma corrente anche senza l’utilizzo del prefisso
<code class="language-plaintext highlighter-rouge">std::</code>.</p>

<p>Nei programmi di medie/grandi dimensioni, è buona prassi limitare il
più possibile l’uso di <code class="language-plaintext highlighter-rouge">using</code> in quanto aumenta le probabilità di
conflitti tra entità definite nel programma e quelle della libreria
importata (in particolare, la libreria standard che è di dimensioni
ragguardevoli e definisce migliaia di entità). Per questo motivo,
nei programmi di esempio che presento tenderò a preferire l’uso
esplicito del prefisso <code class="language-plaintext highlighter-rouge">std::</code> invece di scrivere <code class="language-plaintext highlighter-rouge">using</code>, anche se
la dimensione molto modesta degli esempi non giustificherebbe in
linea di principio questa cautela.</p>

<p>In questo corso, siete liberi di scrivere <code class="language-plaintext highlighter-rouge">using</code> nei vostri
esercizi e nel progetto se vi fa comodo o lo preferite.</p>

<h3 id="perché-il-compilatore-segnala-lerrore-domain_error-is-not-a-member-of-std">Perché il compilatore segnala l’errore <code class="language-plaintext highlighter-rouge">domain_error</code> is not a member of <code class="language-plaintext highlighter-rouge">std</code>?</h3>

<p>È possibile che la causa di questo problema sia l’uso di un
compilatore C++ datato o con una libreria standard organizzata in
modo leggermente diverso da quella fornita con il mio
compilatore. Per risolvere il problema occorre innanzi tutto
assicurarsi di usare un compilatore C++ recente e conforme agli
standard attuali. I programmi discussi a lezione sono stati
verificati con il compilatore <a href="https://developer.apple.com/download/more/?=xcode"><strong>Clang versione
11</strong></a> e con il
compilatore <a href="https://formulae.brew.sh/formula/gcc"><strong>GCC versione
9.2.0</strong></a> su MacOS.</p>

<p>Se il problema si manifesta con un compilatore recente, si può
provare ad aggiungere la seguente direttiva all’inizio del
programma:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdexcept&gt;</span><span class="cp">
</span></code></pre></div></div>

<p>Se nemmeno ciò risolve il problema, è possibile modificare
sistematicamente il codice che fa uso di eccezioni come
<code class="language-plaintext highlighter-rouge">domain_error</code> nel seguente modo. In ogni file in cui si fa uso di
tali eccezioni, si aggiunge all’inizio una classe <code class="language-plaintext highlighter-rouge">my_exception</code>
vuota che definisce un nuovo tipo di eccezione:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">my_exception</span> <span class="p">{</span> <span class="p">};</span>
</code></pre></div></div>

<p>Successivamente, si sostituisce ogni occorrenza di</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">domain_error</span><span class="p">(</span><span class="s">"..."</span><span class="p">)</span>
</code></pre></div></div>

<p>o di altra eccezione con</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">throw</span> <span class="nf">my_exception</span><span class="p">();</span>
</code></pre></div></div>

<h3 id="non-è-meglio-stampare-un-messaggio-di-errore-invece-di-lanciare-uneccezione">Non è meglio stampare un messaggio di errore invece di lanciare un’eccezione?</h3>

<p>In generale no, per due diversi motivi.</p>

<p>Innanzi tutto, c’è una distinzione fondamentale tra il comando</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">domain_error</span><span class="p">(</span><span class="s">"..."</span><span class="p">);</span>
</code></pre></div></div>

<p>e in generale qualunque lancio di eccezione con <code class="language-plaintext highlighter-rouge">throw</code> ed un
comando</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"errore"</span><span class="p">;</span>
</code></pre></div></div>

<p>Il secondo, infatti, si limita a stampare un messaggio sul
terminale, mentre il primo causa la terminazione del programma (se
l’eccezione lanciata non è “catturata” usando un costrutto specifico
del linguaggio). In particolare, il codice che segue <code class="language-plaintext highlighter-rouge">throw</code> non
viene eseguito, come è giusto che sia dal momento che si è rilevata
una anomalia, mentre quello che segue <code class="language-plaintext highlighter-rouge">std::cout</code> sì. Continuare
l’esecuzione del programma anche quando si è rilevata una anomalia
può essere causa di errori insidiosi e difficili da scovare, in
quanto l’anomalia può manifestarsi solo molto tempo dopo la sua
individuazione e in una parte del programma molto distante da quella
che l’ha rilevata.</p>

<p>Una linea guida da seguire sempre è la seguente: quando si rileva
una anomalia (per es. un tentativo di divisione per zero) la si deve
segnalare <em>immediatamente</em> senza cercare di “mettere pezze” al
codice che l’ha rilevata. A volte questo principio viene detto
<strong>fail fast</strong>.</p>

<p>Il secondo motivo che, in alcune circostanze, rende obbligatorio il
lancio di un’eccezione (con <code class="language-plaintext highlighter-rouge">throw</code>) rispetto alla semplice stampa
di un messaggio di errore (es. su <code class="language-plaintext highlighter-rouge">std::cout</code>) è illustrato dal
seguente esempio. Supponiamo di voler scrivere una funzione
“robusta” per calcolare il fattoriale di un numero intero <code class="language-plaintext highlighter-rouge">n</code>, che
prenda in considerazione la possibilità che <code class="language-plaintext highlighter-rouge">n</code> sia negativo:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">fact</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"errore, fattoriale di un numero negativo"</span><span class="p">;</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Durante la compilazione di questo programma, il compilatore emette
un messaggio di avvertimento simile al seguente:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  warning: control may reach end of non-void function
</code></pre></div></div>

<p>In effetti ci si potrebbe chiedere che cosa restituisce la funzione
<code class="language-plaintext highlighter-rouge">fact</code> se applicata a un numero negativo. Il codice qui sopra non
contiene alcuna indicazione a riguardo. Modificarlo nel seguente
modo</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">fact</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"errore, fattoriale di un numero negativo"</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// Uso -1 per segnalare l'errore al chiamante</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>è una chiara violazione della linea guida citata poco sopra: con
<code class="language-plaintext highlighter-rouge">return -1</code> stiamo “mettendo una pezza” alla funzione <code class="language-plaintext highlighter-rouge">fact</code>, magari
con la (buona) intenzione di segnalare a chi l’ha applicata che l’ha
fatto con un argomento illegale. Tuttavia, non interrompendo il
programma, stiamo snaturando la funzione e sperando che, chi l’ha
applicata male, controlli se il risultato è <code class="language-plaintext highlighter-rouge">-1</code> per vedere se
qualcosa è andato storto. Tutto ciò è da evitare:</p>

<ol>
  <li>La funzione <code class="language-plaintext highlighter-rouge">fact</code> non ha un valore di ritorno sensato da
restituire quando <code class="language-plaintext highlighter-rouge">n</code> è negativo (ci sono estensioni della
funzione fattoriale anche a numeri negativi, ma questo è un altro
discorso). Pertanto, non dovrebbe esserci nessun <code class="language-plaintext highlighter-rouge">return</code> di
“salvataggio” al di fuori di quelli nominali.</li>
  <li>Se <code class="language-plaintext highlighter-rouge">n</code> è negativo, l’errore non è da ricercarsi all’interno della
funzione <code class="language-plaintext highlighter-rouge">fact</code>, bensì nel codice di chi l’ha applicata.</li>
</ol>

<p>Il lancio di un’eccezione ci permette di scrivere una versione
sensata di <code class="language-plaintext highlighter-rouge">fact</code>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">fact</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">domain_error</span><span class="p">(</span><span class="s">"fattoriale di un numero negativo"</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Il compilatore sa che <code class="language-plaintext highlighter-rouge">throw</code> causa la terminazione della funzione,
pertanto non si ostina a richiedere un valore di ritorno nel caso in
cui <code class="language-plaintext highlighter-rouge">n</code> sia negativo. Inoltre, lanciando un’eccezione costringiamo
chi ha applicato male <code class="language-plaintext highlighter-rouge">fact</code> a guardare il suo codice, perché
l’errore è lì.</p>

<h2 id="oggetti-mutabili">Oggetti mutabili</h2>

<h3 id="come-faccio-a-fornire-dati-da-elaborare-al-mio-programma">Come faccio a fornire dati da elaborare al mio programma?</h3>

<p>Trascurando il caso di programmi che fanno uso di interfacce
grafiche, la cui complessità va un po’ oltre gli obiettivi di questo
corso, ci sono essenzialmente tre modi per fornire ai programmi C++
le informazioni che devono elaborare:</p>

<ul>
  <li>dal terminale;</li>
  <li>da un file;</li>
  <li>attraverso gli argomenti della riga di comando.</li>
</ul>

<p>Illustriamo i tre metodi risolvendo un semplice problema: supponiamo
di voler scrivere un programma che, presi in ingresso un numero
arbitrario di numeri interi, ne calcola la somma. Il seguente
programma risolve il problema leggendo i numeri dal terminale:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="n">s</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Somma = "</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I numeri vengono letti dallo <strong>stream di input</strong> <code class="language-plaintext highlighter-rouge">std::cin</code> ed il
risultato è prodotto sull <strong>stream di output</strong>
<code class="language-plaintext highlighter-rouge">std::cout</code>. L’operazione di lettura di un numero <code class="language-plaintext highlighter-rouge">std::cin &gt;&gt; n</code>
può essere usata come test in modo che il ciclo <code class="language-plaintext highlighter-rouge">while</code> termini
quando non ci sono più numeri da leggere. Eseguendo questo programma
(dal terminale) si nota che il programma resta in attesa
dell’input. Segue un esempio di esecuzione (il prompt <code class="language-plaintext highlighter-rouge">$</code> potrà
essere diverso a seconda del sistema operativo e delle impostazioni
del terminale):</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./somma_terminale.exe
1
2
3
4
5
Somma <span class="o">=</span> 15
</code></pre></div></div>

<p>Per segnalare al programma che l’input è finito si tiene premuto il
tasto <code class="language-plaintext highlighter-rouge">CTRL</code> insieme a <code class="language-plaintext highlighter-rouge">D</code> (in MacOS o Linux) o <code class="language-plaintext highlighter-rouge">Z</code> (in Windows).</p>

<p>Lo stesso programma si può usare per sommare i numeri da un file
usando la cosiddetta <em>redirezione</em> dell’input. Se il file
<a href="../../assets/code/input/numeri.txt"><code class="language-plaintext highlighter-rouge">numeri.txt</code></a> contiene gli
stessi numeri da 1 a 5 (separati da spazi o da ritorni a capo),
allora avremo</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./somma_terminale.exe &lt; numeri.txt
Somma <span class="o">=</span> 15
</code></pre></div></div>

<p>dove l’<strong>operatore di redirezione</strong> <code class="language-plaintext highlighter-rouge">&lt;</code> ha l’effetto di “collegare”
il contenuto del file <code class="language-plaintext highlighter-rouge">numeri.txt</code> allo stream di input <code class="language-plaintext highlighter-rouge">std::cin</code>
del programma.</p>

<p>Il seguente programma risolve lo stesso problema, ma aprendo
esplicitamente un file (nel caso specifico, lo stesso <code class="language-plaintext highlighter-rouge">numeri.txt</code>
di cui sopra) dal quale vengono letti i numeri:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">is</span><span class="p">(</span><span class="s">"numeri.txt"</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">is</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="n">s</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Somma = "</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Si noti l’inclusione della libreria <code class="language-plaintext highlighter-rouge">fstream</code> per poter accedere
alle classi che consentono la lettura/scrittura di file, l’apertura
del file desiderato all’inizio del <code class="language-plaintext highlighter-rouge">main</code> ed il fatto che, nel ciclo
<code class="language-plaintext highlighter-rouge">while</code>, i numeri sono ora letti dallo stream <code class="language-plaintext highlighter-rouge">is</code> invece che da
<code class="language-plaintext highlighter-rouge">std::cin</code>. In questo caso l’esecuzione del programma non richiede
alcun input esplicito da parte di chi lo invoca, in quanto il
programma legge autonomamente il contenuto del file <code class="language-plaintext highlighter-rouge">numeri.txt</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./somma_file.exe
Somma <span class="o">=</span> 15
</code></pre></div></div>

<p>Occorre prestare attenzione al fatto che il file <code class="language-plaintext highlighter-rouge">numeri.txt</code> si
trovi nella stessa cartella dalla quale viene eseguito il programma.</p>

<p>Il seguente programma risolve lo stesso problema, questa volta
leggendo i numeri dalla linea di comando:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">+=</span> <span class="n">std</span><span class="o">::</span><span class="n">stoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Somma = "</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notiamo innanzi tutto che la funzione <code class="language-plaintext highlighter-rouge">main</code> viene dichiarata con
due argomenti, il primo <code class="language-plaintext highlighter-rouge">argc</code> di tipo <code class="language-plaintext highlighter-rouge">int</code> che contiene il numero
degli argomenti passati sulla linea di comando ed il secondo, un
array di puntatori a carattere (stringhe) <code class="language-plaintext highlighter-rouge">argv</code>, che contiene gli
argomenti veri e propri. La funzione di libreria <code class="language-plaintext highlighter-rouge">std::stoi</code>,
dichiarata in <code class="language-plaintext highlighter-rouge">string</code>, converte una stringa nel numero intero
corrispondente (<code class="language-plaintext highlighter-rouge">stoi</code> è la contrazione di string-to-int). Al
momento dell’esecuzione del programma occorrerà fornire i numeri da
sommare direttamente sulla linea di comando, dopo il nome del
programma:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./somma_linea_comando.exe 1 2 3 4 5
Somma <span class="o">=</span> 15
</code></pre></div></div>

<p>Si noti che, in questo caso specifico, l’argomento <code class="language-plaintext highlighter-rouge">argc</code> avrà come
valore 6 in quanto oltre ai 5 argomenti forniti esplicitamente (i
numeri da 1 a 5), <code class="language-plaintext highlighter-rouge">argv</code> contiene anche (in posizione 0) il nome del
programma stesso (lo si può verificare facilmente aggiungendo
l’istruzione <code class="language-plaintext highlighter-rouge">std::cout &lt;&lt; argv[0] &lt;&lt; std::endl</code> al programma qui
sopra).</p>

<p>Per una maggiore flessibilità è possibile combinare i metodi visti
sopra, per esempio passando sulla linea di comando non i numeri da
sommare, bensì il nome del file in cui trovarli:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">domain_error</span><span class="p">(</span><span class="s">"nome del file mancante"</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">is</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">is</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="n">s</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Somma = "</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Se <code class="language-plaintext highlighter-rouge">argc</code> è minore di 2, allora chi ha invocato il programma si è
dimenticato di specificare l’argomento ed il programma termina con
un errore. Altrimenti, il programma apre il file specificato e
prosegue come visto prima. Un esempio di esecuzione è il seguente:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./somma_file_linea_comando.exe numeri.txt
Somma <span class="o">=</span> 15
</code></pre></div></div>

<p>Tutti i programmi qui discussi sono <a href="../assets/code/input">disponibili in questa
cartella</a>.</p>

<h3 id="a-cosa-serve-const">A cosa serve <code class="language-plaintext highlighter-rouge">const</code>?</h3>

<p>Il qualificatore <code class="language-plaintext highlighter-rouge">const</code> serve per dare al compilatore qualche
informazione in più sulle nostre intenzioni di utilizzo di un
oggetto. Qualificando il riferimento a un oggetto (o una variabile)
come <code class="language-plaintext highlighter-rouge">const</code> diciamo che non intendiamo modificarlo. In questo modo,
il compilatore può segnalare con un errore i tentativi
(evidentemente sbagliati) di eseguire una operazione su un oggetto
che può modificarlo.</p>

<p>Il qualificatore <code class="language-plaintext highlighter-rouge">const</code> si può usare nelle seguenti posizioni:</p>

<ol>
  <li>
    <p>Per indicare che una funzione o un metodo non modifica un
argomento passato per riferimento. Un esempio classico è
l’operatore <code class="language-plaintext highlighter-rouge">&lt;&lt;</code>, qui sotto illustrato dalla soluzione di uno
degli esercizi:</p>

    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</code></pre></div>    </div>

    <p>Entrambi gli argomenti sono passati per riferimento. Il primo
argomento <code class="language-plaintext highlighter-rouge">os</code> è privo del qualificatore <code class="language-plaintext highlighter-rouge">const</code>, e infatti
l’operatore avrà solitamente come effetto quello di “scrivere”
dati nello stream <code class="language-plaintext highlighter-rouge">os</code> (dunque modificherà quell’oggetto). Al
contrario, il secondo argomento ha il qualificatore <code class="language-plaintext highlighter-rouge">const</code> in
quanto non ci si aspetta che l’operatore <code class="language-plaintext highlighter-rouge">&lt;&lt;</code> modifichi
quell’oggetto (però avrà in generale bisogno di leggere
informazioni di quell’oggetto per poterlo stampare sullo
stream).</p>
  </li>
  <li>
    <p>Per indicare che un metodo non modifica l’oggetto ricevente su
cui viene invocato. Ad esempio:</p>

    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">Complex</span> <span class="n">mul</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Per indicare che non si intende modificare il valore di una
variabile locale dopo la sua inizializzazione. Ad esempio:</p>
    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">const</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// ERRORE!</span>
</code></pre></div>    </div>
  </li>
</ol>

<div class="footer">
  <p><img class="license-icon" src="assets/images/by-nc-sa.svg" width="60px" /> Tutto il materiale didattico incluso è distribuito con licenza
<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.it">CC BY-NC-SA
4.0</a>.
Documento generato il 06/04/2022.</p>
</div>


    </div>
    <script type="text/javascript" src="../js/mathjax.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  </body>
</html>
