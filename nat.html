<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Quando fa diecimila fattoriale?</title>
    <link href="https://fonts.googleapis.com/css?family=Fira+Code:300,600|Fira+Sans:300,600&display=swap&subset=latin-ext" rel="stylesheet"/>
    <link rel="stylesheet" type="text/css" href="https://use.fontawesome.com/releases/v5.10.1/css/all.css"/>
    <link rel="stylesheet" type="text/css" href="assets/css/vs.css"/>
    <style>
      html {
	  font-family: "Fira Sans", sans-serif;
	  font-size: 16pt;
	  background-image: url('assets/images/background.png');
	  background-attachment: fixed;
	  margin: 0;
	  padding: 0;
      }

      pre, code {
	  font-family: "Fira Code", monospace;
      }

      body {
	  max-width: 900px;
	  margin: 1ex auto;
	  counter-reset: chapter;
	  background-color: white;
	  padding: 16px 32px;
	  box-shadow: 0 0 4px 4px #A0A0A0;
	  border-radius: 8px;
      }

      h1 {
	  font-weight: 300;
	  color: white;
	  background: #004080;
	  text-align: center;
	  margin: -16px -32px 16px -32px;
	  padding: 16px 32px;
	  border-radius: 8px 8px 0 0;
      }

      h2 {
	  /* margin: 0 -32px; */
	  padding: 4px 0 0 0;
      }

      i.fas, i.far {
	  font-size: smaller;
	  margin: 0 0.25ex;
      }

      a, a:visited {
	  color: teal;
	  text-decoration: none;
      }

      a:hover {
	  color: white;
	  background-color: teal;
	  border-radius: 0.5ex;
	  margin: 0.1ex -0.25ex;
	  padding: 0.1ex 0.25ex;
	  text-decoration: none;
      }

      .legend {
	  display: inline-block;
	  width: 300px;
	  padding: 0 8px 0 0;
	  float: right;
	  font-size: small;
	  background: orange;
	  border-radius: 3px;
      }

      .footer {
	  display: inline-block;
	  font-size: small;
      }
    </style>
  </head>
  <body>
    <div id="root" class="index">
      <h1 id="quanto-fa-diecimila-fattoriale">Quanto fa diecimila fattoriale?</h1>

<h2 id="preambolo">Preambolo</h2>

<p>MC microcomputer è stata una famosa rivista di informatica
distribuita in Italia dal 1981 al 2001. In un articolo della rubrica
“intelligiochi” del numero 104 (febbraio 1991) fu offerto in regalo
un abbonamento annuale al primo lettore che fosse stato in grado di
determinare l’ultima cifra non nulla del fattoriale di 10000. Al
tempo il problema non era banale, al punto da meritare un premio, in
parte a causa della limitata potenza di calcolo dei PC e in parte
perché era più difficile accedere a linguaggi e programmi che
consentissero di lavorare agevolmente con “grandi numeri”. In questo
caso di studio risolviamo il problema realizzando una classe
C++ per la rappresentazione di numeri naturali a precisione
arbitraria.  Gli interessati possono leggere l’articolo in
questione online nell’<a href="http://www.mc-online.it">archivio online di MC
microcomputer</a>.</p>

<h2 id="descrizione-del-problema">Descrizione del problema</h2>

<p>Anche oggi, il numero 10000! è <strong>troppo grande</strong> per essere
rappresentato usando i tipi primitivi del C++. Se si prova
a eseguire il seguente
<a href="assets/code/contenitori/naive_fact.cc">programma</a></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">fact</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">n</span> <span class="o">*</span> <span class="n">fact</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">fact</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>si ottiene come risultato (errato) 0 e il risultato non cambia
nemmeno se si usa <code class="language-plaintext highlighter-rouge">long long</code> come tipo di ritorno della funzione
<code class="language-plaintext highlighter-rouge">fact</code> (il tipo primitivo <code class="language-plaintext highlighter-rouge">long long</code> è il più grande tipo primitivo
numerico intero fornito dal C++). Se si usa <code class="language-plaintext highlighter-rouge">double</code> come tipo di
ritorno di <code class="language-plaintext highlighter-rouge">fact</code> il risultato ottenuto è <code class="language-plaintext highlighter-rouge">inf</code>. In tutti questi
casi, il problema è riconducibile al fatto che i tipi primitivi del
C++ non sono in grado di rappresentare (con precisione) numeri
“troppo grandi”. La definizione esatta di “troppo grande” dipende
dal calcolatore utilizzato, ma nella maggior parte dei PC
di oggi il numero intero più grande che può essere memorizzato in
una variabile di tipo <code class="language-plaintext highlighter-rouge">int</code> è $2^{32} - 1$ oppure $2^{64} - 1$,
mentre il valore di 10000! (che ha più di 35000 cifre) eccede
ampiamente questi limiti.</p>

<p>Possiamo risolvere il problema definendo una classe <code class="language-plaintext highlighter-rouge">nat</code> che ci
consenta di rappresentare <strong>numeri naturali arbitrariamente
grandi</strong>, o più precisamente la cui dimensione è limitata
esclusivamente dalla memoria disponibile sul calcolatore.</p>

<h2 id="rappresentazione-di-un-numero-naturale">Rappresentazione di un numero naturale</h2>

<p>L’idea di base per rappresentare numeri naturali arbitrariamente
grandi è molto semplice: usiamo la <strong>notazione posizionale</strong> e un
vettore per memorizzare un numero arbitrario di <strong>cifre</strong>. Ad
esempio, il numero naturale 1234 verrà rappresentato come un oggetto
<code class="language-plaintext highlighter-rouge">std::vector&lt;int&gt;</code> di dimensione 4 i cui elementi sono 4, 3, 2
e 1. In generale, il vettore con elementi $a_0, a_1, \dots, a_{n-1}$
in cui $0 \leq a_i &lt; 10$ rappresenterà il numero naturale</p>

\[\sum_{i=0}^{n-1} a_i \cdot 10^i\]

<p>Oltre a rappresentare numeri naturali avremo bisogno di calcolare
somme e moltiplicazioni. Lo faremo realizzando in C++ gli algoritmi
di somma e moltiplicazione che abbiamo imparato alla scuola
elementare.</p>

<h2 id="realizzazione-della-classe-nat">Realizzazione della classe <code class="language-plaintext highlighter-rouge">nat</code></h2>

<p>Iniziamo con l’includere i file della libreria standard per fare
input/output e per usare <code class="language-plaintext highlighter-rouge">std::vector</code>. L’inclusione di <code class="language-plaintext highlighter-rouge">iomanip</code> è
necessaria per l’uso di alcuni “manipolatori” che torneranno utili
alla fine dell’esercitazione.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></code></pre></div></div>

<p>Successivamente, definiamo una costante $B$ che rappresenta la base
di riferimento per i numeri naturali. Per il momento assumiamo $B =
10$ in modo da mantenere la rappresentazione e gli algoritmi di
calcolo allineati il più possibile con l’intuizione di numeri
naturali come sequenze di cifre decimali. In seguito vedremo che
scegliendo una base più grande potremo rendere il calcolo più
efficiente.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="n">K</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">B</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// B = 10^K</span>
</code></pre></div></div>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">nat</span> <span class="p">{</span>
<span class="nl">private:</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span> <span class="c1">// ogni elemento è &gt;= 0 e &lt; B</span>
  <span class="n">nat</span> <span class="n">mul</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="nl">public:</span>
  <span class="n">nat</span><span class="p">(</span><span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span>
  <span class="kt">int</span> <span class="n">digit</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">nat</span> <span class="n">add</span><span class="p">(</span><span class="k">const</span> <span class="n">nat</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">nat</span> <span class="n">mul</span><span class="p">(</span><span class="k">const</span> <span class="n">nat</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<ul>
  <li>La classe ha un unico campo <code class="language-plaintext highlighter-rouge">data</code>, il vettore che contiene le
cifre del numero naturale.</li>
  <li>Il costruttore ci permette di inizializzare un oggetto di
tipo <code class="language-plaintext highlighter-rouge">nat</code> con un valore di tipo <code class="language-plaintext highlighter-rouge">int</code>.</li>
  <li>Il metodo <code class="language-plaintext highlighter-rouge">size</code> restituisce il numero di cifre di cui è composto
il numero naturale.</li>
  <li>Il metodo <code class="language-plaintext highlighter-rouge">digit</code> restituisce l’$i$-esima cifra del numero
naturale.</li>
  <li>I metodi pubblici <code class="language-plaintext highlighter-rouge">add</code> e <code class="language-plaintext highlighter-rouge">mul</code> realizzano le operazioni di somma
e moltiplicazione.</li>
  <li>Il metodo privato <code class="language-plaintext highlighter-rouge">mul</code> realizza l’operazione di moltiplicazione
nel caso speciale in cui l’operando di destra sia un numero intero
compreso tra 0 e $B$ (estremi inclusi). Sarà utile nella
realizzazione del metodo pubblico <code class="language-plaintext highlighter-rouge">mul</code>.</li>
</ul>

<h2 id="costruttore-e-metodi-di-accesso">Costruttore e metodi di accesso</h2>

<p>Il costruttore di <code class="language-plaintext highlighter-rouge">nat</code> ha un argomento <code class="language-plaintext highlighter-rouge">n</code> che dobbiamo convertire
in una sequenza di cifre decimali.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">nat</span><span class="o">::</span><span class="n">nat</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">domain_error</span><span class="p">(</span><span class="s">"negative int"</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">B</span><span class="p">);</span>
    <span class="n">n</span> <span class="o">/=</span> <span class="n">B</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Ogni cifra del numero naturale è ottenuta calcolando il resto della
divisione di <code class="language-plaintext highlighter-rouge">n</code> per la base $B$, e poi dividendo <code class="language-plaintext highlighter-rouge">n</code> per la base
per calcolare le cifre successive. Usando il metodo <code class="language-plaintext highlighter-rouge">push_back</code>
aggiungiamo cifre via via più significative in fondo al vettore
<code class="language-plaintext highlighter-rouge">data</code>, coerentemente con la rappresentazione che abbiamo scelto.</p>

<p>Da notare che, se <code class="language-plaintext highlighter-rouge">n</code> è zero, il vettore <code class="language-plaintext highlighter-rouge">data</code> rimane vuoto. Dal
punto di vista del <strong>valore</strong> del numero naturale non c’è problema
(la somma di zero elementi è proprio zero). Tuttavia, dovremo
ricordarci di gestire separatamente questo caso particolare quando
stamperemo un numero naturale sul terminale.</p>

<p>Il metodo <code class="language-plaintext highlighter-rouge">size</code> è già stato definito all’interno della classe e
restituisce la dimensione del vettore <code class="language-plaintext highlighter-rouge">data</code>. Definiamo il metodo
<code class="language-plaintext highlighter-rouge">digit</code> in modo tale che, chiedendo una cifra inesistente (purché
con indice non negativo) si ottenga il valore 0, come se tutti i
numeri naturali avessero infinite cifre 0 oltre a quella più
significativa. Questa scelta nell’implementazione di <code class="language-plaintext highlighter-rouge">digit</code>
semplificherà la successiva realizzazione del metodo <code class="language-plaintext highlighter-rouge">add</code>.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">nat</span><span class="o">::</span><span class="n">digit</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">domain_error</span><span class="p">(</span><span class="s">"negative index"</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">?</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="somma-di-numeri-naturali">Somma di numeri naturali</h2>

<p>Come anticipato, per sommare due numeri naturali usiamo l’algoritmo
visto alla scuola elementare. L’idea è di sommare le cifre
corrispondenti dei due numeri naturali, partendo da quelle meno
significative e ricordandosi di propagare l’eventuale “riporto”. Il
codice è mostrato qui sotto:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">nat</span> <span class="n">nat</span><span class="o">::</span><span class="n">add</span><span class="p">(</span><span class="k">const</span> <span class="n">nat</span><span class="o">&amp;</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">nat</span> <span class="n">r</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">()</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">digit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">n</span><span class="p">.</span><span class="n">digit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">carry</span><span class="p">;</span>
    <span class="n">r</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">k</span> <span class="o">%</span> <span class="n">B</span><span class="p">);</span>
    <span class="n">carry</span> <span class="o">=</span> <span class="n">k</span> <span class="o">/</span> <span class="n">B</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">carry</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">r</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">carry</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>La variabile locale <code class="language-plaintext highlighter-rouge">r</code> contiene il risultato della somma dei due
numeri naturali, quello rappresentato dall’oggetto ricevente e
l’argomento <code class="language-plaintext highlighter-rouge">n</code>. Ricordiamo che il costruttore di <code class="language-plaintext highlighter-rouge">nat</code> ha un
argomento con valore di default <code class="language-plaintext highlighter-rouge">0</code>, dunque <code class="language-plaintext highlighter-rouge">r</code> è implicitamente
inizializzato a zero.</li>
  <li>La variabile locale <code class="language-plaintext highlighter-rouge">carry</code> rappresenta il “riporto”
nell’operazione di somma cifra-a-cifra dei due numeri
naturali. Per sua natura, il riporto sarà sempre un numero
nell’intervallo $[0,B)$. Inizialmente il riporto è 0.</li>
  <li>Il ciclo <code class="language-plaintext highlighter-rouge">for</code> realizza la somma delle cifre corrispondenti dei
due numeri naturali. Notiamo che <code class="language-plaintext highlighter-rouge">i</code> varia da 0 fino all’indice
della cifra più significativa del numero naturale più “lungo” tra i
due che stiamo sommando. Dunque, <code class="language-plaintext highlighter-rouge">i</code> non sarà sempre un indice
valido per i vettori di entrambi i numeri naturali, ma per come è
stato realizzato il metodo <code class="language-plaintext highlighter-rouge">digit</code> avremo l’illusione di lavorare
con numeri naturali i cui vettori di cifre hanno la stessa
dimensione.</li>
  <li>La variabile <code class="language-plaintext highlighter-rouge">k</code> contiene la somma di due cifre corrispondenti dei
due numeri da sommare e dell’eventuale riporto. Nel risultato
aggiungiamo via via il modulo di <code class="language-plaintext highlighter-rouge">k</code> rispetto alla base $B$ e
aggiorniamo il riporto.</li>
  <li>L’<code class="language-plaintext highlighter-rouge">if</code> che segue il ciclo <code class="language-plaintext highlighter-rouge">for</code> è fondamentale per aggiungere come
ultima cifra del risultato il riporto, qualora questo sia non
nullo (immaginate di sommare $1$ e $9$ per capire perché questa
operazione è necessaria).</li>
</ul>

<h2 id="moltiplicazione-di-numeri-naturali">Moltiplicazione di numeri naturali</h2>

<p>La moltiplicazione di due numeri naturali $m$ ed $n$ si ottiene
sommando i risultati parziali ottenuti moltiplicando $m$ per ogni
cifra di $n$. Ogni moltiplicazione di $m$ e una singola cifra di $n$
va opportunamente “scalata” in base alla posizione della cifra di
$n$ presa in considerazione.</p>

<p>Come passo intermedio per realizzare la moltiplicazione, realizziamo
il metodo privato <code class="language-plaintext highlighter-rouge">mul</code> che moltiplica un numero naturale $m$ per un
numero $n$ “piccolo”, cioè compreso nell’intervallo $0 \leq n \leq
B$. Il codice è abbastanza simile a quello di <code class="language-plaintext highlighter-rouge">add</code>, tranne per il
fatto che ogni cifra di $m$ viene moltiplicata per $n$:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">nat</span> <span class="n">nat</span><span class="o">::</span><span class="n">mul</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">B</span><span class="p">)</span> <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">domain_error</span><span class="p">(</span><span class="s">"multiplier out of range"</span><span class="p">);</span>
  <span class="n">nat</span> <span class="n">r</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="n">carry</span><span class="p">;</span>
    <span class="n">r</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">k</span> <span class="o">%</span> <span class="n">B</span><span class="p">);</span>
    <span class="n">carry</span> <span class="o">=</span> <span class="n">k</span> <span class="o">/</span> <span class="n">B</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">carry</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">r</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">carry</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A questo punto, il codice per la moltiplicazione nel caso generale
si ottiene combinando opportunamente i metodi <code class="language-plaintext highlighter-rouge">add</code> e <code class="language-plaintext highlighter-rouge">mul</code> già
realizzati.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">nat</span> <span class="n">nat</span><span class="o">::</span><span class="n">mul</span><span class="p">(</span><span class="k">const</span> <span class="n">nat</span><span class="o">&amp;</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">nat</span> <span class="n">r</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">mul</span><span class="p">(</span><span class="n">B</span><span class="p">).</span><span class="n">add</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">mul</span><span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
  <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>La variabile locale <code class="language-plaintext highlighter-rouge">r</code> contiene il risultato parziale della
moltiplicazione che, ripetiamo, è la somma delle moltiplicazioni
di $m$ (l’oggetto ricevente) per ogni cifra di $n$, fatta
l’opportuna scala rispetto alla posizione della cifra
considerata. Per questo motivo, è comodo iniziare le
moltiplicazioni a partire dalla <strong>cifra più significativa</strong> di $n$
(si noti che il ciclo <code class="language-plaintext highlighter-rouge">for</code> procede “al contrario”, inizializzando
<code class="language-plaintext highlighter-rouge">i</code> all’indice più grande, corrispondente alla cifra più
significativa di $n$, e decrementandolo fino a 0 incluso).</li>
  <li>A ogni iterazione, il risultato parziale <code class="language-plaintext highlighter-rouge">r</code> viene moltiplicato
per la base $B$ grazie all’espressione <code class="language-plaintext highlighter-rouge">r.mul(B)</code>, e
successivamente sommato al risultato della moltiplicazione di $m$
(l’oggetto ricevente) per la cifra con indice <code class="language-plaintext highlighter-rouge">i</code> di $n$.</li>
  <li>La notazione <code class="language-plaintext highlighter-rouge">this-&gt;</code> è superflua (può essere omessa, come abbiamo
visto nella lezione precedente), ma è qui inclusa per evidenziare
che l’operazione <code class="language-plaintext highlighter-rouge">this-&gt;mul(n.data[i])</code> moltiplica l’oggetto
ricevente per la cifra <code class="language-plaintext highlighter-rouge">n.data[i]</code>.</li>
</ul>

<h2 id="overloading-di-operatori">Overloading di operatori</h2>

<p>Ora che abbiamo una prima realizzazione di <code class="language-plaintext highlighter-rouge">nat</code> possiamo fare
overloading di <code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">*</code> e <code class="language-plaintext highlighter-rouge">&lt;&lt;</code> in modo da poter usare gli operatori
tradizionali in forma infissa e stampare numeri naturali sul
terminale alla pari degli altri tipi numerici primitivi.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">nat</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">nat</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">nat</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">nat</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">nat</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">nat</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">mul</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">nat</span><span class="o">&amp;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">"0"</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
      <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">.</span><span class="n">digit</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Per quanto riguarda <code class="language-plaintext highlighter-rouge">+</code> e <code class="language-plaintext highlighter-rouge">*</code> non ci sono novità rispetto ad altre
definizioni analoghe viste a lezione. Per l’operatore <code class="language-plaintext highlighter-rouge">&lt;&lt;</code>, l’idea
di base è quella di stampare tutte le cifre che compongono il numero
naturale partendo da quella più significativa. L’unico aspetto
critico è la possibilità che il numero naturale 0 sia rappresentato
con un vettore con zero elementi, nel qual caso stampiamo
esplicitamente la cifra <code class="language-plaintext highlighter-rouge">0</code>, altrimenti non vedremmo nulla sul
terminale.</p>

<h2 id="proviamo-il-codice">Proviamo il codice</h2>

<p>La definizione della funzione <code class="language-plaintext highlighter-rouge">fact</code> sui numeri naturali a
precisione arbitraria è sotanzialmente la stessa illustrata
all’inizio dell’esercitazione, cambia solo il tipo di ritorno della
funzione (<code class="language-plaintext highlighter-rouge">nat</code> invece di <code class="language-plaintext highlighter-rouge">int</code>) e il fatto che i numeri interi <code class="language-plaintext highlighter-rouge">1</code>
ed <code class="language-plaintext highlighter-rouge">n</code> devono essere esplicitamente convertiti in numeri naturali
per mezzo del costruttore di <code class="language-plaintext highlighter-rouge">nat</code>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">nat</span> <span class="nf">fact</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">nat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="n">nat</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">fact</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A questo punto possiamo verificare il funzionamento del codice
calcolando ad esempio il fattoriale di 100:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">fact</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Purtroppo, se si tenta di calcolare il fattoriale di numeri più
grandi, per esempio di 1000 o di 10000, si osserva che il tempo di
calcolo è inaccettabile.</p>

<h2 id="migliorare-lefficienza-del-codice">Migliorare l’efficienza del codice</h2>

<p>Al fine di rendere il codice più efficiente, notiamo innanzi tutto
che il metodo pubblico <code class="language-plaintext highlighter-rouge">mul</code>, che calcola $m \times n$, esegue un
numero di iterazioni pari al numero di cifre di $n$. Ne segue che
possiamo limitare il numero di iterazioni usando la proprietà
commutativa della moltiplicazione e calcolando $m \times n$ oppure
$n \times m$ a seconda di quale numero, tra $m$ ed $n$, ha meno
cifre. Questa ottimizzazione può essere realizzata con una semplice
modifica dell’operatore <code class="language-plaintext highlighter-rouge">*</code>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">nat</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">nat</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="n">nat</span><span class="o">&amp;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">m</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">?</span> <span class="n">n</span><span class="p">.</span><span class="n">mul</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">:</span> <span class="n">m</span><span class="p">.</span><span class="n">mul</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Usiamo il metodo <code class="language-plaintext highlighter-rouge">size</code> per stabilire quale tra i due fattori ha
meno cifre e scegliamo quel fattore come oggetto ricevente per
l’invocazione del metodo <code class="language-plaintext highlighter-rouge">mul</code>. Anche con questa ottimizzazione, il
calcolo di 10000! richiede parecchio tempo (per avere un
riferimento, sulla mia macchina occorrono più di due minuti per
vedere il risultato).</p>

<p>La seconda ottimizzazione che possiamo realizzare facilmente si basa
sulla considerazione che, usando il tipo <code class="language-plaintext highlighter-rouge">int</code> per memorizzare le
cifre decimali dei numeri naturali, non stiamo sfruttando al meglio
le operazioni primitive di somma e moltiplicazione messe a
disposizione dal calcolatore. Possiamo scegliere una “base” $B$ di
riferimento più grande, in modo da aumentare la dimensione delle
singole “cifre” e contestualmente diminuire il numero di “cifre” che
usiamo per codificare i numeri naturali (metto “cifre” tra
virgolette perché seguendo questa strada avremo elementi del vettore
<code class="language-plaintext highlighter-rouge">data</code> che, in generale, potranno essere numeri maggiori di 10). Per
semplicità è opportuno usare una base che sia una potenza di 10,
facendo attenzione a scegliere un valore di $B$ tale che $B^2 - 1$
sia ancora rappresentabile con un valore di tipo <code class="language-plaintext highlighter-rouge">int</code> (ciò
garantisce che il valore della variabile <code class="language-plaintext highlighter-rouge">k</code> nel metodo privato
<code class="language-plaintext highlighter-rouge">mul</code> possa essere contenuto in una variabile di tipo <code class="language-plaintext highlighter-rouge">int</code> senza
perdita di informazione). Scegliamo dunque:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="n">K</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">B</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span> <span class="c1">// B = 10^K</span>
</code></pre></div></div>

<p>Con queste modifiche il codice scritto in precedenza è quasi
completamente corretto, ad eccezione dell’operatore <code class="language-plaintext highlighter-rouge">&lt;&lt;</code>. Infatti,
ora bisogna fare attenzione a che ogni elemento del vettore <code class="language-plaintext highlighter-rouge">data</code>
(tranne quello più significativo) sia stampato usando esattamente
$K$ cifre decimali. Per ottenere questo effetto, è possibile usare
dei cosiddetti <strong>manipolatori di input/output</strong> che, in combinazione
con <code class="language-plaintext highlighter-rouge">&lt;&lt;</code>, stabiliscono l’<strong>ampiezza</strong> dei numeri da stampare (ovvero
il numero minimo di caratteri da usare per la stampa di un numero) e
anche il carattere di <strong>riempimento</strong>, che in genere è uno spazio
oppure, nel nostro caso, la cifra <code class="language-plaintext highlighter-rouge">0</code>. Otteniamo il seguente codice:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">nat</span><span class="o">&amp;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="n">K</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setfill</span><span class="p">(</span><span class="sc">'0'</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"0"</span><span class="p">;</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">.</span><span class="n">digit</span><span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
      <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="n">K</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setfill</span><span class="p">(</span><span class="sc">'0'</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">.</span><span class="n">digit</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Con queste modifiche, è possibile calcolare 10000! in tempi
ragionevoli (per avere un riferimento, sulla mia macchina il calcolo
termina in poco meno di 7 secondi).</p>

<p>Il codice descritto in questo documento è <a href="assets/code/contenitori/nat.cc">incluso
nell’archivio</a>.</p>

<div class="footer">
  <p><img class="license-icon" src="assets/images/by-nc-sa.svg" width="60px" />
Tutto il materiale didattico incluso è distribuito con licenza <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.it">CC
BY-NC-SA
4.0</a>.
Documento generato il 06/04/2022.  &lt;/div&gt;</p>

</div>

    </div>
    <script type="text/javascript" src="../js/mathjax.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  </body>
</html>
