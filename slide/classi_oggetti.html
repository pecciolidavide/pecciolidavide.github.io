<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Classi e oggetti</title>
    <script>
      (function() {
	  if (window.location.search != "?handout") {
	      document.write('<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/reveal.js@3.9.2/css/reveal.css">');
	  }
      })();
    </script>
    <link rel="stylesheet" type="text/css" href="../assets/css/vs.css">
    <link rel="stylesheet" type="text/css" href="../assets/css/main.css">
  </head>
  <body>
    <div class="reveal">
      <div id="root" class="slides">
	<h1 class="no_toc" id="programmazione-avanzata">PROGRAMMAZIONE AVANZATA</h1>

<h2 class="sezione" id="2-classi-e-oggetti">2 Classi e oggetti</h2>

<ul class="smaller" id="markdown-toc">
  <li><a href="#programmazione-orientata-agli-oggetti" id="markdown-toc-programmazione-orientata-agli-oggetti">Programmazione orientata agli oggetti</a></li>
  <li><a href="#principio-di-incapsulamento" id="markdown-toc-principio-di-incapsulamento">Principio di incapsulamento</a></li>
  <li><a href="#rat" id="markdown-toc-rat">La classe <code class="language-plaintext highlighter-rouge">rat</code></a></li>
  <li><a href="#definizione-di-campi" id="markdown-toc-definizione-di-campi">Definizione di campi</a></li>
  <li><a href="#costruttore-di-una-classe" id="markdown-toc-costruttore-di-una-classe">Costruttore di una classe</a></li>
  <li><a href="#ancora-sul-costruttore" id="markdown-toc-ancora-sul-costruttore">Ancora sul costruttore</a></li>
  <li><a href="#esempio-creazione-di-una-istanza" id="markdown-toc-esempio-creazione-di-una-istanza">Esempio: creazione di una istanza</a></li>
  <li><a href="#metodi" id="markdown-toc-metodi">Metodi</a></li>
  <li><a href="#invocazione-di-un-metodo" id="markdown-toc-invocazione-di-un-metodo">Invocazione di un metodo</a></li>
  <li><a href="#metodi-di-accesso-controllato" id="markdown-toc-metodi-di-accesso-controllato">Metodi di accesso controllato</a></li>
  <li><a href="#metodi-esterni" id="markdown-toc-metodi-esterni">Metodi esterni</a></li>
  <li><a href="#metodi-che-invocano-altri-metodi" id="markdown-toc-metodi-che-invocano-altri-metodi">Metodi che invocano altri metodi</a></li>
  <li><a href="#overloading-di-operatori" id="markdown-toc-overloading-di-operatori">Overloading di operatori</a></li>
  <li><a href="#metodi-privati" id="markdown-toc-metodi-privati">Metodi privati</a></li>
  <li><a href="#costruttori-con-inizializzatore-privato" id="markdown-toc-costruttori-con-inizializzatore-privato">Costruttori con inizializzatore privato</a></li>
  <li><a href="#ciclo-di-vita-di-un-oggetto" id="markdown-toc-ciclo-di-vita-di-un-oggetto">Ciclo di vita di un oggetto</a></li>
  <li><a href="#esercizi" id="markdown-toc-esercizi">Esercizi</a></li>
</ul>

<div class="license">
  <p><img class="license-icon" src="../assets/images/by-nc-sa.svg" width="80px" />
Documento distribuito con licenza <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.it">CC BY-NC-SA 4.0</a>. Generato il 06/04/2022.</p>
</div>

<h1 id="programmazione-orientata-agli-oggetti">Programmazione orientata agli oggetti</h1>

<p>Una <strong>classe</strong> rappresenta una famiglia omogenea di entità che:</p>

<ul>
  <li>hanno la <em>stessa rappresentazione</em> in memoria</li>
  <li>supportano le <em>stesse operazioni</em></li>
</ul>

<h2 id="esempio">Esempio</h2>

<ul>
  <li>i numeri razionali sono rappresentati da una coppia di numeri
interi, di cui il secondo è positivo</li>
  <li>i numeri razionali possono essere sommati, sottratti,
moltiplicati, ecc.</li>
</ul>

<p>Un <strong>oggetto</strong> rappresenta una singola entità della classe ed è
caratterizzato da:</p>

<ul>
  <li>la <em>classe di appartenenza</em></li>
  <li>un <em>identificatore</em> (nome/indirizzo in memoria)</li>
  <li>una regione di memoria che contiene la sua rappresentazione</li>
</ul>

<h1 id="principio-di-incapsulamento">Principio di incapsulamento</h1>

<p>Ogni classe ha una parte <strong>privata</strong> e una <strong>pubblica</strong>:</p>

<ul>
  <li>La parte <strong>privata</strong> è accessibile/utilizzabile solo dall’interno
della classe.</li>
  <li>La parte <strong>pubblica</strong> è accessibile/utilizzabile ovunque nel
programma.</li>
</ul>

<h2 id="perché-lincapsulamento-è-utile">Perché l’incapsulamento è utile?</h2>

<ol>
  <li><em>Facilita il riuso e la modifica del codice</em>: la parte privata di
una classe può cambiare indipendentemente dal resto del
programma.</li>
  <li><em>Impedisce accessi diretti</em> alla parte privata di una classe,
prevenendo errori involontari o maliziosi.</li>
</ol>

<h2 id="esempio-di-accesso-diretto">Esempio di accesso diretto</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">rat</span> <span class="n">a</span> <span class="o">=</span> <span class="n">rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">a</span><span class="p">.</span><span class="n">den</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>           <span class="c1">// accesso diretto al campo den</span>
</code></pre></div></div>

<h1 id="rat">La classe <code class="language-plaintext highlighter-rouge">rat</code></h1>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">rat</span> <span class="p">{</span>
<span class="nl">private:</span>
  <span class="p">...</span>

<span class="nl">public:</span>
  <span class="p">...</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="note">Note</h2>

<ul>
  <li>La parola chiave <code class="language-plaintext highlighter-rouge">class</code> introduce una nuova <strong>classe</strong> e un nuovo
<strong>tipo</strong></li>
  <li>Il nome <code class="language-plaintext highlighter-rouge">rat</code> può essere usato ovunque può comparire un tipo</li>
  <li>La classe contiene <strong>membri</strong> (per ora omessi e sostituiti da
<code class="language-plaintext highlighter-rouge">...</code>)  che includono <strong>campi</strong> (dati) e <strong>metodi</strong> (operazioni)</li>
  <li>I membri <strong>privati</strong> sono accessibili solo dall’interno della classe</li>
  <li>I membri <strong>pubblici</strong> sono accessibili da ogni parte del programma</li>
  <li>Possono esserci più blocchi pubblici e privati, in qualunque ordine</li>
</ul>

<h1 id="definizione-di-campi">Definizione di campi</h1>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">rat</span> <span class="p">{</span>
<span class="nl">private:</span>
  <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">den</span><span class="p">;</span> <span class="c1">// den &gt; 0</span>

<span class="nl">public:</span>
  <span class="p">...</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="note-1">Note</h2>

<ul>
  <li>I <strong>campi</strong> specificano la rappresentazione degli oggetti di tipo
<code class="language-plaintext highlighter-rouge">rat</code></li>
  <li>Qui abbiamo due campi di tipo <code class="language-plaintext highlighter-rouge">int</code> (numeratore, denominatore)</li>
  <li>In generale, i campi possono essere in numero e di tipo arbitrario</li>
  <li>Il commento accanto a <code class="language-plaintext highlighter-rouge">den</code> specifica un <strong>invariante di classe</strong>:
ci aspettiamo che nel ciclo di vita di un oggetto di tipo <code class="language-plaintext highlighter-rouge">rat</code>
la condizione <code class="language-plaintext highlighter-rouge">den &gt; 0</code> sia sempre verificata, ma è <em>responsabilità
del programmatore</em> fare in modo che questa proprietà sia vera</li>
</ul>

<h1 id="costruttore-di-una-classe">Costruttore di una classe</h1>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">rat</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="nl">public:</span>
  <span class="n">rat</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// dichiarazione del costruttore</span>
  <span class="p">...</span>
<span class="p">};</span>

<span class="n">rat</span><span class="o">::</span><span class="n">rat</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// definizione del costruttore</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="p">...</span> <span class="c1">// stesso codice della funzione rational</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Il <strong>costruttore</strong> realizza un’operazione speciale eseguita al
momento della <strong>creazione</strong> di un oggetto di tipo <code class="language-plaintext highlighter-rouge">rat</code></li>
  <li>La <strong>dichiarazione</strong> viene fatta all’interno della classe</li>
  <li>La <strong>definizione</strong> può essere fatta all’interno o (come qui) all’esterno</li>
  <li>Il nome del costruttore <strong>coincide</strong> con quello della classe</li>
  <li>La sintassi <code class="language-plaintext highlighter-rouge">rat::</code> indica che definiamo il costruttore della
classe <code class="language-plaintext highlighter-rouge">rat</code></li>
  <li>Il costruttore <strong>non ha un tipo di ritorno</strong></li>
</ul>

<h1 id="ancora-sul-costruttore">Ancora sul costruttore</h1>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rat</span><span class="o">::</span><span class="n">rat</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">den</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">num</span> <span class="o">=</span> <span class="o">-</span><span class="n">a</span><span class="p">;</span>
    <span class="n">den</span> <span class="o">=</span> <span class="o">-</span><span class="n">b</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">domain_error</span><span class="p">(</span><span class="s">"division by zero"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="note-2">Note</h2>

<ul>
  <li>La funzione del costruttore è quello di <em>preparare l’oggetto al
primo utilizzo</em>, inizializzando opportunamente i campi della
classe</li>
  <li>È responsabilità del costruttore garantire che eventuali
invarianti di classe siano soddisfatti (o segnalare un <strong>errore</strong>
se ciò è impossibile)</li>
  <li>Il costruttore si riferisce ai <strong>campi</strong> <code class="language-plaintext highlighter-rouge">num</code> e <code class="language-plaintext highlighter-rouge">den</code>
dell’oggetto che sta inizializzando</li>
</ul>

<h1 id="esempio-creazione-di-una-istanza">Esempio: creazione di una istanza</h1>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">rat</span> <span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// crea il numero razionale 1 / 2</span>
  <span class="n">rat</span> <span class="n">b</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>    <span class="c1">// crea il numero razionale 3 / 1</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">a</code> e <code class="language-plaintext highlighter-rouge">b</code> sono <strong>oggetti</strong> di tipo <code class="language-plaintext highlighter-rouge">rat</code> (anche: sono <strong>istanze</strong>
della classe <code class="language-plaintext highlighter-rouge">rat</code>)</li>
  <li>Il costruttore di <code class="language-plaintext highlighter-rouge">rat</code> viene eseguito ogni volta che si istanzia
<code class="language-plaintext highlighter-rouge">rat</code></li>
  <li>Ogni istanza ha la sua copia (privata) dei campi <code class="language-plaintext highlighter-rouge">num</code> e <code class="language-plaintext highlighter-rouge">den</code></li>
</ul>

<p>Ogni tentativo di accedere ai campi <code class="language-plaintext highlighter-rouge">num</code> e <code class="language-plaintext highlighter-rouge">den</code> dall’esterno di
<code class="language-plaintext highlighter-rouge">rat</code> viene segnalato come errore dal compilatore:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">rat</span> <span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">num</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// ERRORE!</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Non possiamo fare nulla con <code class="language-plaintext highlighter-rouge">rat</code> se non aggiungiamo operazioni
<strong>pubbliche</strong>!</p>

<h1 id="metodi">Metodi</h1>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">rat</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="nl">public:</span>
  <span class="kt">int</span> <span class="n">get_num</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">num</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">int</span> <span class="n">get_den</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">den</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="note-3">Note</h2>

<ul>
  <li>I <strong>metodi</strong> sono le operazioni eseguibili su istanze di una
classe</li>
  <li>Qui <strong>dichiariamo</strong> e <strong>definiamo</strong> i metodi <code class="language-plaintext highlighter-rouge">get_num</code> e
<code class="language-plaintext highlighter-rouge">get_den</code>, per leggere numeratore e denominatore di un <code class="language-plaintext highlighter-rouge">rat</code></li>
  <li>Il qualificatore <code class="language-plaintext highlighter-rouge">const</code> indica che queste operazioni <strong>non
modificano</strong> l’istanza su cui vengono invocate (si limitano a
leggere dati)</li>
  <li>Metodi semplici (come <code class="language-plaintext highlighter-rouge">get_num</code> e <code class="language-plaintext highlighter-rouge">get_den</code>) possono essere
definiti internamente alla classe</li>
  <li>Metodi complessi (es. <code class="language-plaintext highlighter-rouge">rat::rat</code>) sono solitamente definiti
all’esterno</li>
</ul>

<h1 id="invocazione-di-un-metodo">Invocazione di un metodo</h1>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">rat</span> <span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// stampa 1</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">get_den</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// stampa 2</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="note-4">Note</h2>

<ul>
  <li><strong>Invochiamo</strong> il metodo <code class="language-plaintext highlighter-rouge">get_num</code> su <code class="language-plaintext highlighter-rouge">a</code> per ottenere il
numeratore di <code class="language-plaintext highlighter-rouge">a</code></li>
  <li><strong>Invochiamo</strong> il metodo <code class="language-plaintext highlighter-rouge">get_den</code> su <code class="language-plaintext highlighter-rouge">a</code> per ottenere il
denominatore di <code class="language-plaintext highlighter-rouge">a</code></li>
  <li>L’oggetto che riceve la richiesta di eseguire una certa operazione
(es. <code class="language-plaintext highlighter-rouge">get_num</code>) è detto <strong>oggetto ricevente</strong> (è quello a sinistra
di <code class="language-plaintext highlighter-rouge">.</code>)</li>
  <li>Il metodo <code class="language-plaintext highlighter-rouge">get_num</code>/<code class="language-plaintext highlighter-rouge">get_den</code> accede al campo <code class="language-plaintext highlighter-rouge">num</code>/<code class="language-plaintext highlighter-rouge">den</code>
dell’oggetto ricevente su cui è stato invocato</li>
</ul>

<h2 id="sintassi-generale-di-una-invocazione-di-metodo">Sintassi generale di una invocazione di metodo</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	oggetto ricevente . nome metodo ( argomenti )
</code></pre></div></div>

<h1 id="metodi-di-accesso-controllato">Metodi di accesso controllato</h1>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">rat</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="nl">public:</span>
  <span class="kt">int</span> <span class="n">get_num</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">num</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">int</span> <span class="n">get_den</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">den</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="get_num-e-get_den-sono-metodi-di-accesso-controllato"><code class="language-plaintext highlighter-rouge">get_num</code> e <code class="language-plaintext highlighter-rouge">get_den</code> sono <strong>metodi di accesso controllato</strong></h2>

<ul>
  <li>i campi <code class="language-plaintext highlighter-rouge">num</code>/<code class="language-plaintext highlighter-rouge">den</code> sono privati $\Rightarrow$ inaccessibili nel
resto del programma</li>
  <li>i metodi <code class="language-plaintext highlighter-rouge">get_num</code>/<code class="language-plaintext highlighter-rouge">get_den</code> sono pubblici $\Rightarrow$ usabili
da chiunque</li>
  <li>i metodi <code class="language-plaintext highlighter-rouge">get_num</code>/<code class="language-plaintext highlighter-rouge">get_den</code> permettono di <strong>leggere</strong> <code class="language-plaintext highlighter-rouge">num</code>/<code class="language-plaintext highlighter-rouge">den</code></li>
  <li><code class="language-plaintext highlighter-rouge">private</code>+<code class="language-plaintext highlighter-rouge">public</code>+metodi di accesso = <em>controllo fine su chi può
fare cosa</em></li>
</ul>

<h2 id="esempio-1">Esempio</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">rat</span> <span class="nf">a</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">get_num</span><span class="p">();</span> <span class="c1">// posso leggere num</span>
  <span class="n">a</span><span class="p">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>          <span class="c1">// NON POSSO scrivere num</span>
</code></pre></div></div>

<h1 id="metodi-esterni">Metodi esterni</h1>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">rat</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">rat</span> <span class="n">add</span><span class="p">(</span><span class="k">const</span> <span class="n">rat</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">rat</span> <span class="n">neg</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">rat</span> <span class="n">rat</span><span class="o">::</span><span class="n">add</span><span class="p">(</span><span class="k">const</span> <span class="n">rat</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">rat</span><span class="p">(</span><span class="n">num</span> <span class="o">*</span> <span class="n">b</span><span class="p">.</span><span class="n">den</span> <span class="o">+</span> <span class="n">b</span><span class="p">.</span><span class="n">num</span> <span class="o">*</span> <span class="n">den</span><span class="p">,</span> <span class="n">den</span> <span class="o">*</span> <span class="n">b</span><span class="p">.</span><span class="n">den</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">rat</span> <span class="n">rat</span><span class="o">::</span><span class="n">neg</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">rat</span><span class="p">(</span><span class="o">-</span><span class="n">num</span><span class="p">,</span> <span class="n">den</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><strong>Dichiariamo</strong> (internamente) e <strong>definiamo</strong> (esternamente)
<code class="language-plaintext highlighter-rouge">add</code> e <code class="language-plaintext highlighter-rouge">neg</code></li>
  <li>Per riferirsi ai campi di un oggetto diverso da quello ricevente
(es. <code class="language-plaintext highlighter-rouge">b</code>) occorre specificare l’oggetto in questione (es. <code class="language-plaintext highlighter-rouge">b.num</code>)</li>
  <li>È possibile <em>accedere al campo privato</em> <code class="language-plaintext highlighter-rouge">num</code> dell’oggetto <code class="language-plaintext highlighter-rouge">b</code>
poiché:
    <ol>
      <li><code class="language-plaintext highlighter-rouge">rat::add</code> è un metodo della classe <code class="language-plaintext highlighter-rouge">rat</code></li>
      <li><code class="language-plaintext highlighter-rouge">b</code> è una istanza di <code class="language-plaintext highlighter-rouge">rat</code></li>
    </ol>
  </li>
</ul>

<h1 id="metodi-che-invocano-altri-metodi">Metodi che invocano altri metodi</h1>

<ul>
  <li>Abbiamo già realizzato <code class="language-plaintext highlighter-rouge">add</code> e <code class="language-plaintext highlighter-rouge">neg</code></li>
  <li>Per non duplicare codice, calcoliamo <code class="language-plaintext highlighter-rouge">a-b</code> come <code class="language-plaintext highlighter-rouge">a+(-b)</code></li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">rat</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">rat</span> <span class="n">sub</span><span class="p">(</span><span class="k">const</span> <span class="n">rat</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">rat</span> <span class="n">rat</span><span class="o">::</span><span class="n">sub</span><span class="p">(</span><span class="k">const</span> <span class="n">rat</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">add</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">neg</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="una-spiegazione-complicata-per-un-concetto-semplice">Una spiegazione complicata per un concetto semplice</h2>

<ul>
  <li>Per invocare un metodo <code class="language-plaintext highlighter-rouge">m</code> sull’oggetto ricevente l’invocazione di un
altro metodo, è sufficiente scrivere <code class="language-plaintext highlighter-rouge">m()</code> senza ricevente</li>
  <li><code class="language-plaintext highlighter-rouge">add(...)</code> invoca <code class="language-plaintext highlighter-rouge">add</code> sull’oggetto ricevente l’invocazione di
<code class="language-plaintext highlighter-rouge">sub</code></li>
  <li>Volendo essere <strong>espliciti</strong> si può scrivere <code class="language-plaintext highlighter-rouge">this-&gt;add(b.neg())</code></li>
  <li><code class="language-plaintext highlighter-rouge">this</code> è un puntatore all’oggetto ricevente (non lo useremo mai, o quasi)</li>
</ul>

<h1 id="overloading-di-operatori">Overloading di operatori</h1>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rat</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">rat</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">rat</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">rat</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">get_den</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">get_num</span><span class="p">();</span>
  <span class="k">else</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">get_num</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" / "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">get_den</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>L’<strong>overloading</strong> ci permette di definire il significato degli
operatori <code class="language-plaintext highlighter-rouge">+</code> e <code class="language-plaintext highlighter-rouge">&lt;&lt;</code> (ed eventualmente altri) quando li usiamo con
istanze di <code class="language-plaintext highlighter-rouge">rat</code></li>
  <li>Queste sono funzioni, <strong>non</strong> metodi di <code class="language-plaintext highlighter-rouge">rat</code></li>
</ul>

<h2 id="esempio-2">Esempio</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">rat</span> <span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">rat</span> <span class="n">b</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// stampa 10 / 8</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="metodi-privati">Metodi privati</h1>

<p>Supponiamo di voler dotare la classe <code class="language-plaintext highlighter-rouge">rat</code> di un secondo
costruttore, sulla falsariga di quanto fatto nella <a href="funzioni.html">libreria di
funzioni</a>.</p>

<div class="skip" style="margin-top: -1em"></div>

<div class="columns ">
  <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">rat</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="nl">public:</span>
  <span class="n">rat</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">rat</span><span class="p">(</span><span class="kt">double</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">rat</span><span class="o">::</span><span class="n">rat</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">den</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="n">rat</span><span class="o">::</span><span class="n">rat</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
  <span class="p">...</span> <span class="o">?</span> <span class="p">...</span>
<span class="p">}</span>
</code></pre></div>  </div>

  <ul>
    <li>Per realizzare il secondo costruttore vorremmo poter usare il
codice già scritto per il primo, come fatto per <a href="funzioni.html#rat_double_int">la funzione
<code class="language-plaintext highlighter-rouge">rat</code></a></li>
    <li>Purtroppo, in C++ non è sempre facile chiamare un costruttore da
un altro</li>
    <li>Idea: <strong>fattorizzare</strong> in un metodo ausiliario la parte comune dei
due costruttori</li>
    <li>Tale metodo ausiliario, in quanto tale, è di interesse
esclusivamente per la realizzazione della classe, ma non per i
suoi utilizzatori. Può essere dichiarato <strong>privato</strong>.</li>
  </ul>

</div>

<h1 id="costruttori-con-inizializzatore-privato">Costruttori con inizializzatore privato</h1>

<div class="columns ">
  <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">rat</span> <span class="p">{</span>
<span class="nl">private:</span>
  <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">den</span><span class="p">;</span>
  <span class="c1">// init è privato</span>
  <span class="kt">void</span> <span class="n">init</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="nl">public:</span>
  <span class="n">rat</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">rat</span><span class="p">(</span><span class="kt">double</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">};</span>

<span class="n">rat</span><span class="o">::</span><span class="n">rat</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">init</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>  </div>

  <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">rat</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">den</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">num</span> <span class="o">=</span> <span class="o">-</span><span class="n">a</span><span class="p">;</span>
    <span class="n">den</span> <span class="o">=</span> <span class="o">-</span><span class="n">b</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">throw</span> <span class="p">...</span>
<span class="p">}</span>




<span class="n">rat</span><span class="o">::</span><span class="n">rat</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
  <span class="n">init</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">m</span><span class="p">),</span> <span class="n">m</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>  </div>
</div>

<h1 id="ciclo-di-vita-di-un-oggetto">Ciclo di vita di un oggetto</h1>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">...</span>
  <span class="p">{</span>
    <span class="c1">// qui f non esiste ancora</span>
    <span class="p">...</span>
    <span class="n">rat</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="c1">// da qui in avanti è possibile usare f</span>
    <span class="p">...</span>
    <span class="c1">// qui f viene "distrutto"</span>
  <span class="p">}</span>
  <span class="c1">// qui f non esiste più</span>
  <span class="p">...</span>
</code></pre></div></div>

<h2 id="note-5">Note</h2>

<ul>
  <li>Un oggetto esiste dal punto in cui è dichiarato fino alla fine del
blocco in cui è dichiarato</li>
  <li>È possibile creare oggetti che “sopravvivono” anche dopo che
l’esecuzione continua oltre il blocco in cui sono stati
creati. Questo meccanismo prende il nome di <strong>allocazione dinamica
della memoria</strong> (non avremo tempo per illustrarlo in questo corso).</li>
</ul>

<h1 id="esercizi">Esercizi</h1>

<ol>
  <li>
    <p>Completare la classe <code class="language-plaintext highlighter-rouge">rat</code> realizzando metodi (esterni)
corrispondenti a tutte le operazioni considerate nella <a href="funzioni.html">libreria
di funzioni</a>.</p>
  </li>
  <li>
    <p>Definire gli operatori overloaded <code class="language-plaintext highlighter-rouge">==</code>, <code class="language-plaintext highlighter-rouge">!=</code>, <code class="language-plaintext highlighter-rouge">&lt;</code>, <code class="language-plaintext highlighter-rouge">&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;=</code>,
<code class="language-plaintext highlighter-rouge">&gt;=</code> per la classe <code class="language-plaintext highlighter-rouge">rat</code>.</p>
  </li>
  <li>
    <p>Definire una classe <code class="language-plaintext highlighter-rouge">Complex</code> per rappresentare numeri complessi
e dotarla di metodi per leggere parte reale e immaginaria e per
eseguire le seguenti operazioni: somma, sottrazione, negazione,
moltiplicazione, divisione, modulo, reciproco,
coniugato. Definire operatori overloaded <code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">-</code>, <code class="language-plaintext highlighter-rouge">*</code>, <code class="language-plaintext highlighter-rouge">/</code>, <code class="language-plaintext highlighter-rouge">&lt;&lt;</code>
per numeri complessi.</p>
  </li>
  <li>
    <p>Si supponga di dover definire una classe <code class="language-plaintext highlighter-rouge">Time</code> per modellare
un’ora del giorno e che la classe debba fornire i seguenti
metodi</p>

    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span>  <span class="n">Time</span><span class="o">::</span><span class="n">get_hour</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// ora</span>
<span class="kt">int</span>  <span class="n">Time</span><span class="o">::</span><span class="n">get_mins</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// minuti</span>
<span class="kt">int</span>  <span class="n">Time</span><span class="o">::</span><span class="n">get_secs</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// secondi</span>
<span class="n">Time</span> <span class="n">Time</span><span class="o">::</span><span class="n">elapse</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</code></pre></div>    </div>

    <p>in cui l’ultimo metodo fa avanzare l’ora di <code class="language-plaintext highlighter-rouge">s</code> secondi. Quale
potrebbe essere una rappresentazione ragionevole per questa
classe?</p>
  </li>
</ol>

      </div>
    </div>
    <script type="text/javascript" src="../js/slider.js"></script>
    <script>
      (function() {
	  if (window.location.search != "?handout") {
	      document.write('<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/reveal.js@3.9.2/js/reveal.min.js"><\/script>');
	  }
      })();
    </script>
    <script>
      initialize_slider();
      if (window.location.search != "?handout") {
	  // Setup Reveal
	  Reveal.initialize({
	      controls:    false,  // No control arrows
	      slideNumber: 'c/t',  // Print slide number
	      center:      false,  // Do not align slide vertically
	      progress:    false,  // Do not display progress bar
	      hash:        true,   // Store slide number in URL
	      transition:  'none', // Transition mode
	      transitionSpeed: 'fast',
	      width:       848,
	      height:      600,
	      margin:      0,
	      pdfSeparateFragments: false,
	  });
      }
    </script>
    <script type="text/javascript" src="../js/mathjax.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  </body>
</html>
