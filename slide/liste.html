<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Liste e iteratori</title>
    <script>
      (function() {
	  if (window.location.search != "?handout") {
	      document.write('<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/reveal.js@3.9.2/css/reveal.css">');
	  }
      })();
    </script>
    <link rel="stylesheet" type="text/css" href="../assets/css/vs.css">
    <link rel="stylesheet" type="text/css" href="../assets/css/main.css">
  </head>
  <body>
    <div class="reveal">
      <div id="root" class="slides">
	<h1 class="no_toc" id="programmazione-avanzata">PROGRAMMAZIONE AVANZATA</h1>

<h2 class="sezione" id="5-liste-e-iteratori">5 Liste e iteratori</h2>

<ul class="smaller" id="markdown-toc">
  <li><a href="#rappresentazione-di-vettori" id="markdown-toc-rappresentazione-di-vettori">Rappresentazione di vettori</a></li>
  <li><a href="#rappresentazione-di-liste" id="markdown-toc-rappresentazione-di-liste">Rappresentazione di liste</a></li>
  <li><a href="#esempio-ricerca-di-un-elemento-nullo" id="markdown-toc-esempio-ricerca-di-un-elemento-nullo">Esempio: ricerca di un elemento nullo</a></li>
  <li><a href="#iteratori" id="markdown-toc-iteratori">Iteratori</a></li>
  <li><a href="#esempio-insiemi-mutabili" id="markdown-toc-esempio-insiemi-mutabili">Esempio: insiemi mutabili</a></li>
  <li><a href="#ricerca-di-un-elemento" id="markdown-toc-ricerca-di-un-elemento">Ricerca di un elemento</a></li>
  <li><a href="#rimozione-di-un-elemento" id="markdown-toc-rimozione-di-un-elemento">Rimozione di un elemento</a></li>
  <li><a href="#inserimento-di-un-elemento" id="markdown-toc-inserimento-di-un-elemento">Inserimento di un elemento</a></li>
  <li><a href="#stampa-di-insiemi" id="markdown-toc-stampa-di-insiemi">Stampa di insiemi</a></li>
  <li><a href="#stampa-di-insiemi-con-funzione-amica" id="markdown-toc-stampa-di-insiemi-con-funzione-amica">Stampa di insiemi con funzione amica</a></li>
  <li><a href="#esercizi" id="markdown-toc-esercizi">Esercizi</a></li>
</ul>

<div class="license">
  <p><img class="license-icon" src="../assets/images/by-nc-sa.svg" width="80px" />
Documento distribuito con licenza <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.it">CC BY-NC-SA 4.0</a>. Generato il 06/04/2022.</p>
</div>

<h1 id="rappresentazione-di-vettori">Rappresentazione di vettori</h1>

<h2 id="dentro-stdvector">Dentro <code class="language-plaintext highlighter-rouge">std::vector</code></h2>

<div class="skip" style="margin-top: 1em"></div>

<table>
  <tbody>
    <tr>
      <td>$a_0$</td>
      <td>$a_1$</td>
      <td>$a_2$</td>
      <td>$a_3$</td>
      <td>$\cdots$</td>
      <td>$a_{n-1}$</td>
    </tr>
  </tbody>
</table>

<h2 id="note">Note</h2>

<ul>
  <li>Gli elementi si trovano in una regione <strong>contigua</strong> di memoria</li>
  <li>È <em>facile accedere</em> a ogni singolo elemento (indirizzo
dell’elemento in posizione $i$ $=$ posizione primo elemento $+$
$i$ $×$ dimensione elemento)</li>
  <li>È <em>costoso inserire o rimuovere</em> un elemento in una posizione
arbitraria in quanto occorre <strong>traslare</strong> tutti quelli che stanno
alla sua destra (il costo è proporzionale alla distanza
dell’elemento dal fondo del vettore)</li>
  <li>È <em>facile inserire o rimuovere</em> un nuovo elemento <em>in fondo</em> (non
sono necessarie traslazioni)</li>
</ul>

<h1 id="rappresentazione-di-liste">Rappresentazione di liste</h1>

<h2 id="dentro-stdlist">Dentro <code class="language-plaintext highlighter-rouge">std::list</code></h2>

<div class="skip" style="margin-top: -1em"></div>

<div class="jekyll-diagrams diagrams graphviz">
  <p><!-- Generated by graphviz version 3.0.0 (20220226.1711)
 -->
<!-- Pages: 1 --></p>
  <svg width="560pt" height="101pt" viewBox="0.00 0.00 560.00 101.39" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 97.39)">
<!-- a0 -->
<g id="node1" class="node">
<title>a0</title>
<text text-anchor="start" x="11.5" y="-25.69" font-family="Fira Sans" font-size="14.00">a₀</text>
<text text-anchor="start" x="28" y="-35.19" font-family="Fira Sans" font-size="14.00">next</text>
<text text-anchor="start" x="27.5" y="-16.19" font-family="Fira Sans" font-size="14.00">prev</text>
<polygon fill="black" stroke="black" points="25.5,-29.39 25.5,-29.39 56.5,-29.39 56.5,-29.39 25.5,-29.39" />
<polygon fill="black" stroke="black" points="25.5,-10.39 25.5,-49.39 25.5,-49.39 25.5,-10.39 25.5,-10.39" />
<path fill="none" stroke="black" d="M20,-9.39C20,-9.39 45,-9.39 45,-9.39 51,-9.39 57,-15.39 57,-21.39 57,-21.39 57,-37.39 57,-37.39 57,-43.39 51,-49.39 45,-49.39 45,-49.39 20,-49.39 20,-49.39 14,-49.39 8,-43.39 8,-37.39 8,-37.39 8,-21.39 8,-21.39 8,-15.39 14,-9.39 20,-9.39" />
</g>
<!-- a1 -->
<g id="node2" class="node">
<title>a1</title>
<text text-anchor="start" x="112.5" y="-35.69" font-family="Fira Sans" font-size="14.00">a₁</text>
<text text-anchor="start" x="129" y="-45.19" font-family="Fira Sans" font-size="14.00">next</text>
<text text-anchor="start" x="128.5" y="-26.19" font-family="Fira Sans" font-size="14.00">prev</text>
<polygon fill="black" stroke="black" points="126.5,-39.39 126.5,-39.39 157.5,-39.39 157.5,-39.39 126.5,-39.39" />
<polygon fill="black" stroke="black" points="126.5,-20.39 126.5,-59.39 126.5,-59.39 126.5,-20.39 126.5,-20.39" />
<path fill="none" stroke="black" d="M121,-19.39C121,-19.39 146,-19.39 146,-19.39 152,-19.39 158,-25.39 158,-31.39 158,-31.39 158,-47.39 158,-47.39 158,-53.39 152,-59.39 146,-59.39 146,-59.39 121,-59.39 121,-59.39 115,-59.39 109,-53.39 109,-47.39 109,-47.39 109,-31.39 109,-31.39 109,-25.39 115,-19.39 121,-19.39" />
</g>
<!-- a0&#45;&gt;a1 -->
<g id="edge1" class="edge">
<title>a0:1&#45;&gt;a1</title>
<path fill="none" stroke="black" d="M57.5,-39.39C69.92,-39.39 83.49,-39.39 95.64,-39.39" />
<polygon fill="black" stroke="black" points="95.75,-41.14 100.75,-39.39 95.75,-37.64 95.75,-41.14" />
</g>
<!-- a1&#45;&gt;a0 -->
<g id="edge6" class="edge">
<title>a1:2&#45;&gt;a0</title>
<path fill="none" stroke="black" d="M142.5,-19.39C142.5,10.38 101.7,-0.02 70.03,-12.58" />
<polygon fill="black" stroke="black" points="69,-11.11 65.03,-14.61 70.32,-14.35 69,-11.11" />
</g>
<!-- a2 -->
<g id="node3" class="node">
<title>a2</title>
<text text-anchor="start" x="213.5" y="-45.69" font-family="Fira Sans" font-size="14.00">a₂</text>
<text text-anchor="start" x="230" y="-55.19" font-family="Fira Sans" font-size="14.00">next</text>
<text text-anchor="start" x="229.5" y="-36.19" font-family="Fira Sans" font-size="14.00">prev</text>
<polygon fill="black" stroke="black" points="227.5,-49.39 227.5,-49.39 258.5,-49.39 258.5,-49.39 227.5,-49.39" />
<polygon fill="black" stroke="black" points="227.5,-30.39 227.5,-69.39 227.5,-69.39 227.5,-30.39 227.5,-30.39" />
<path fill="none" stroke="black" d="M222,-29.39C222,-29.39 247,-29.39 247,-29.39 253,-29.39 259,-35.39 259,-41.39 259,-41.39 259,-57.39 259,-57.39 259,-63.39 253,-69.39 247,-69.39 247,-69.39 222,-69.39 222,-69.39 216,-69.39 210,-63.39 210,-57.39 210,-57.39 210,-41.39 210,-41.39 210,-35.39 216,-29.39 222,-29.39" />
</g>
<!-- a1&#45;&gt;a2 -->
<g id="edge2" class="edge">
<title>a1:1&#45;&gt;a2</title>
<path fill="none" stroke="black" d="M158.5,-49.39C170.92,-49.39 184.49,-49.39 196.64,-49.39" />
<polygon fill="black" stroke="black" points="196.75,-51.14 201.75,-49.39 196.75,-47.64 196.75,-51.14" />
</g>
<!-- a2&#45;&gt;a1 -->
<g id="edge7" class="edge">
<title>a2:2&#45;&gt;a1</title>
<path fill="none" stroke="black" d="M243.5,-29.39C243.5,0.38 202.7,-10.02 171.03,-22.58" />
<polygon fill="black" stroke="black" points="170,-21.11 166.03,-24.61 171.32,-24.35 170,-21.11" />
</g>
<!-- a3 -->
<g id="node4" class="node">
<title>a3</title>
<text text-anchor="start" x="314.5" y="-55.69" font-family="Fira Sans" font-size="14.00">a₃</text>
<text text-anchor="start" x="331" y="-65.19" font-family="Fira Sans" font-size="14.00">next</text>
<text text-anchor="start" x="330.5" y="-46.19" font-family="Fira Sans" font-size="14.00">prev</text>
<polygon fill="black" stroke="black" points="328.5,-59.39 328.5,-59.39 359.5,-59.39 359.5,-59.39 328.5,-59.39" />
<polygon fill="black" stroke="black" points="328.5,-40.39 328.5,-79.39 328.5,-79.39 328.5,-40.39 328.5,-40.39" />
<path fill="none" stroke="black" d="M323,-39.39C323,-39.39 348,-39.39 348,-39.39 354,-39.39 360,-45.39 360,-51.39 360,-51.39 360,-67.39 360,-67.39 360,-73.39 354,-79.39 348,-79.39 348,-79.39 323,-79.39 323,-79.39 317,-79.39 311,-73.39 311,-67.39 311,-67.39 311,-51.39 311,-51.39 311,-45.39 317,-39.39 323,-39.39" />
</g>
<!-- a2&#45;&gt;a3 -->
<g id="edge3" class="edge">
<title>a2:1&#45;&gt;a3</title>
<path fill="none" stroke="black" d="M259.5,-59.39C271.92,-59.39 285.49,-59.39 297.64,-59.39" />
<polygon fill="black" stroke="black" points="297.75,-61.14 302.75,-59.39 297.75,-57.64 297.75,-61.14" />
</g>
<!-- a3&#45;&gt;a2 -->
<g id="edge8" class="edge">
<title>a3:2&#45;&gt;a2</title>
<path fill="none" stroke="black" d="M344.5,-39.39C344.5,-9.62 303.7,-20.02 272.03,-32.58" />
<polygon fill="black" stroke="black" points="271,-31.11 267.03,-34.61 272.32,-34.35 271,-31.11" />
</g>
<!-- dots -->
<g id="node5" class="node">
<title>dots</title>
<text text-anchor="middle" x="419.5" y="-65.69" font-family="Fira Sans" font-size="14.00">⋯</text>
</g>
<!-- a3&#45;&gt;dots -->
<g id="edge4" class="edge">
<title>a3:1&#45;&gt;dots</title>
<path fill="none" stroke="black" d="M360.5,-69.39C373.13,-69.39 387.32,-69.39 398.49,-69.39" />
<polygon fill="black" stroke="black" points="398.72,-71.14 403.72,-69.39 398.72,-67.64 398.72,-71.14" />
</g>
<!-- an -->
<g id="node6" class="node">
<title>an</title>
<text text-anchor="start" x="482.5" y="-65.69" font-family="Fira Sans" font-size="14.00">an&#45;1</text>
<text text-anchor="start" x="515" y="-75.19" font-family="Fira Sans" font-size="14.00">next</text>
<text text-anchor="start" x="514.5" y="-56.19" font-family="Fira Sans" font-size="14.00">prev</text>
<polygon fill="black" stroke="black" points="512.5,-69.39 512.5,-69.39 543.5,-69.39 543.5,-69.39 512.5,-69.39" />
<polygon fill="black" stroke="black" points="512.5,-50.39 512.5,-89.39 512.5,-89.39 512.5,-50.39 512.5,-50.39" />
<path fill="none" stroke="black" d="M491,-49.39C491,-49.39 532,-49.39 532,-49.39 538,-49.39 544,-55.39 544,-61.39 544,-61.39 544,-77.39 544,-77.39 544,-83.39 538,-89.39 532,-89.39 532,-89.39 491,-89.39 491,-89.39 485,-89.39 479,-83.39 479,-77.39 479,-77.39 479,-61.39 479,-61.39 479,-55.39 485,-49.39 491,-49.39" />
</g>
<!-- dots&#45;&gt;an -->
<g id="edge5" class="edge">
<title>dots&#45;&gt;an</title>
<path fill="none" stroke="black" d="M435.36,-69.39C443.76,-69.39 454.75,-69.39 465.73,-69.39" />
<polygon fill="black" stroke="black" points="465.76,-71.14 470.76,-69.39 465.76,-67.64 465.76,-71.14" />
</g>
<!-- an&#45;&gt;dots -->
<g id="edge9" class="edge">
<title>an:2&#45;&gt;dots</title>
<path fill="none" stroke="black" d="M528.5,-49.39C528.5,-13.58 470.4,-41.06 439.43,-58.25" />
<polygon fill="black" stroke="black" points="438.57,-56.73 435.07,-60.7 440.28,-59.78 438.57,-56.73" />
</g>
</g>
</svg>

</div>

<h2 id="note-1">Note</h2>

<ul>
  <li>Ogni elemento è memorizzato in un <strong>nodo</strong> la cui posizione in
memoria è indipendente da quella degli altri nodi e dunque
imprevedibile.</li>
  <li>Ogni nodo contiene un <em>riferimento</em> al successivo e al precedente.</li>
  <li>È <em>costoso raggiungere</em> ogni singolo nodo in quanto occorre
seguire la catena di riferimenti dall’inizio (o dalla fine) (il
costo è proporzionale alla posizione del nodo dall’inizio o dalla
fine)</li>
  <li>Trovato un nodo, è <em>facile rimuoverlo o inserirne</em> un altro prima
o dopo al nodo stesso in quanto non è necessaria alcuna
traslazione, basta aggiornare opportunamente i riferimenti.</li>
  <li><strong>Attenzione</strong>: ogni nodo <strong>occupa più memoria</strong> di un singolo
elemento</li>
</ul>

<h1 id="esempio-ricerca-di-un-elemento-nullo">Esempio: ricerca di un elemento nullo</h1>

<h2 id="vettore">Vettore</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">ricerca</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>L’accesso all’elemento in posizione $i$ ha un costo indipendente
da $i$</li>
  <li>La ricerca ha un costo proporzionale a $n$ (<em>caso pessimo</em>)</li>
</ul>

<h2 id="lista-questo-codice-è-ipotetico-non-cè-loperatore--sulle-liste">Lista (questo codice è <strong>ipotetico</strong>, non c’è l’operatore <code class="language-plaintext highlighter-rouge">[]</code> sulle liste)</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">ricerca</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>L’accesso all’elemento in posizione $i$ ha un costo proporzionale a $i$</li>
  <li>La ricerca ha un costo proporzionale a $n^2$ (<em>caso pessimo</em>)</li>
</ul>

<h1 id="iteratori">Iteratori</h1>

<ul>
  <li>Un <strong>iteratore</strong> è un oggetto mutabile che <strong>indica</strong> un elemento
della lista</li>
  <li><em><code class="language-plaintext highlighter-rouge">std::list&lt;T&gt;::iterator</code></em> è il tipo degli <strong>iteratori</strong> su liste di <code class="language-plaintext highlighter-rouge">T</code></li>
  <li><em><code class="language-plaintext highlighter-rouge">std::list&lt;T&gt;::const_iterator</code></em> è il tipo degli <strong>iteratori
costanti</strong> su liste di <code class="language-plaintext highlighter-rouge">T</code> (questi iteratori non possono
modificare la lista)</li>
  <li>L’operatore <em><code class="language-plaintext highlighter-rouge">++</code></em> sposta l’iteratore all’elemento <strong>successivo</strong></li>
  <li>L’operatore <em><code class="language-plaintext highlighter-rouge">--</code></em> sposta l’iteratore all’elemento <strong>precedente</strong></li>
  <li>L’operatore prefisso <em><code class="language-plaintext highlighter-rouge">*</code></em> <strong>accede</strong> all’elemento</li>
  <li>Il metodo <em><code class="language-plaintext highlighter-rouge">begin()</code></em> crea un iteratore che indica il <strong>primo
elemento</strong></li>
  <li>Il metodo <em><code class="language-plaintext highlighter-rouge">end()</code></em> crea un iteratore che indica l’<strong>elemento
fittizio</strong> successivo all’<strong>ultimo</strong></li>
  <li>Analogamente, i metodi <em><code class="language-plaintext highlighter-rouge">cbegin()</code></em> e <em><code class="language-plaintext highlighter-rouge">cend()</code></em> creano iteratori
costanti</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">ricerca</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">l</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">l</span><span class="p">.</span><span class="n">cend</span><span class="p">())</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">it</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">else</span> <span class="n">it</span><span class="o">++</span><span class="p">;</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="esempio-insiemi-mutabili">Esempio: insiemi mutabili</h1>

<ul>
  <li>Creiamo una classe <code class="language-plaintext highlighter-rouge">Set</code> di <strong>insiemi mutabili</strong>, ovvero insiemi
in cui è possibile inserire e rimuovere elementi</li>
  <li>Usiamo un <strong>contenitore</strong> per mantenere gli elementi dell’insieme</li>
  <li>È conveniente mantenere il <strong>contenitore ordinato</strong>, così la
ricerca di un elemento può interrompersi non appena se ne trova
uno più grande</li>
  <li>Quando si aggiunge un elemento a un insieme occorre <strong>inserirlo</strong>
nel punto giusto (non necessariamente in fondo) per preservare
l’ordine del contenitore</li>
  <li>Per questo motivo, il contenitore appropriato è la <strong>lista</strong> (tra
quelli visti)</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Set</span> <span class="p">{</span>
<span class="nl">private:</span>
  <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span> <span class="c1">// invariante: lista ordinata</span>
<span class="nl">public:</span>
  <span class="kt">int</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="n">contains</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="n">insert</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">remove</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">};</span>
</code></pre></div></div>

<h1 id="ricerca-di-un-elemento">Ricerca di un elemento</h1>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="n">Set</span><span class="o">::</span><span class="n">contains</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">data</span><span class="p">.</span><span class="n">cend</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">)</span> <span class="n">it</span><span class="o">++</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">data</span><span class="p">.</span><span class="n">cend</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">it</span> <span class="o">==</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>usiamo un iteratore <strong>costante</strong> poiché la ricerca non modifica la
lista</li>
  <li>cerchiamo <code class="language-plaintext highlighter-rouge">x</code> all’interno della lista, la ricerca termina quando
si verifica una delle seguenti possibilità:
    <ul>
      <li>abbiamo raggiunto la <strong>fine della lista</strong> (<code class="language-plaintext highlighter-rouge">it == data.cend()</code>),
in tal caso tutti gli elementi già presenti sono minori di <code class="language-plaintext highlighter-rouge">x</code>,
<strong>oppure</strong></li>
      <li>abbiamo trovato un elemento (indicato da <code class="language-plaintext highlighter-rouge">it</code>) che è <strong>maggiore
o uguale</strong> a <code class="language-plaintext highlighter-rouge">x</code></li>
    </ul>
  </li>
  <li>restituiamo <code class="language-plaintext highlighter-rouge">true</code> se <code class="language-plaintext highlighter-rouge">it</code> indica <strong>proprio</strong> <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">false</code> altrimenti</li>
</ul>

<h1 id="rimozione-di-un-elemento">Rimozione di un elemento</h1>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">Set</span><span class="o">::</span><span class="n">remove</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">)</span> <span class="n">it</span><span class="o">++</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">it</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span> <span class="n">data</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>usiamo un iteratore <strong>non costante</strong> poiché la rimozione, in
generale, modifica la lista</li>
  <li>cerchiamo <code class="language-plaintext highlighter-rouge">x</code> all’interno della lista, la ricerca termina quando
si verifica una delle seguenti possibilità:
    <ul>
      <li>abbiamo raggiunto la <strong>fine della lista</strong> (<code class="language-plaintext highlighter-rouge">it == data.cend()</code>),
in tal caso tutti gli elementi già presenti sono minori di <code class="language-plaintext highlighter-rouge">x</code>,
<strong>oppure</strong></li>
      <li>abbiamo trovato un elemento (indicato da <code class="language-plaintext highlighter-rouge">it</code>) che è <strong>maggiore
o uguale</strong> a <code class="language-plaintext highlighter-rouge">x</code></li>
    </ul>
  </li>
  <li>se <code class="language-plaintext highlighter-rouge">x</code> è stato trovato, lo rimuoviamo (il metodo <code class="language-plaintext highlighter-rouge">data.erase(it)</code>
rimuove l’elemento indicato da <code class="language-plaintext highlighter-rouge">it</code> dalla lista <code class="language-plaintext highlighter-rouge">data</code>)</li>
</ul>

<h1 id="inserimento-di-un-elemento">Inserimento di un elemento</h1>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">Set</span><span class="o">::</span><span class="n">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">)</span> <span class="n">it</span><span class="o">++</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">==</span> <span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">||</span> <span class="o">*</span><span class="n">it</span> <span class="o">!=</span> <span class="n">x</span><span class="p">)</span> <span class="n">data</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>usiamo un iteratore <strong>non costante</strong> poiché l’inserimento, in
generale, modifica la lista</li>
  <li>cerchiamo <code class="language-plaintext highlighter-rouge">x</code> all’interno della lista, con un duplice obiettivo:
    <ul>
      <li>se lo troviamo, non dobbiamo inserirlo</li>
      <li>se non lo troviamo, individuiamo il punto giusto in cui inserirlo</li>
    </ul>
  </li>
  <li>la ricerca termina quando si verifica una delle seguenti possibilità:
    <ul>
      <li>abbiamo raggiunto la fine della lista (<code class="language-plaintext highlighter-rouge">it == data.cend()</code>), in
tal caso tutti gli elementi già presenti sono minori di <code class="language-plaintext highlighter-rouge">x</code>, <strong>oppure</strong></li>
      <li>abbiamo trovato un elemento (indicato da <code class="language-plaintext highlighter-rouge">it</code>) che è <strong>maggiore
o uguale</strong> a <code class="language-plaintext highlighter-rouge">x</code></li>
    </ul>
  </li>
  <li>se <code class="language-plaintext highlighter-rouge">x</code> <strong>non</strong> è stato trovato, lo inseriamo <strong>prima</strong> di quello
indicato da <code class="language-plaintext highlighter-rouge">it</code> (se <code class="language-plaintext highlighter-rouge">it == data.end()</code>, l’effetto è quello di
inserirlo <strong>in fondo</strong> alla lista, come deve essere)</li>
</ul>

<h1 id="stampa-di-insiemi">Stampa di insiemi</h1>

<h2 id="dilemma">Dilemma</h2>

<ul>
  <li>Per stampare insiemi sul terminale vorremmo scrivere l’operatore
<code class="language-plaintext highlighter-rouge">&lt;&lt;</code> per la classe <code class="language-plaintext highlighter-rouge">Set</code></li>
  <li>Tale operatore <strong>non è</strong> un membro della classe, pertanto non ha
accesso diretto al campo <code class="language-plaintext highlighter-rouge">data</code> che è privato</li>
  <li>Se rendessimo <strong>pubblico</strong> il campo <code class="language-plaintext highlighter-rouge">data</code> esporremmo la classe
<code class="language-plaintext highlighter-rouge">Set</code> a usi impropri (es. potremmo modificare direttamente la
lista <code class="language-plaintext highlighter-rouge">data</code> violando l’invariante di classe).</li>
</ul>

<h2 id="soluzione">Soluzione</h2>

<p>Il progettista di una classe può definire funzioni <strong>amiche</strong> che,
pur essendo esterne alla classe, hanno accesso ai campi privati
della classe:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Set</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="p">,</span>
                                  <span class="k">const</span> <span class="n">Set</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">};</span>
</code></pre></div></div>

<h1 id="stampa-di-insiemi-con-funzione-amica">Stampa di insiemi con funzione amica</h1>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">Set</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"{"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">cend</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
    <span class="n">it</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">cend</span><span class="p">())</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">","</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"}"</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>l’<code class="language-plaintext highlighter-rouge">if</code> all’interno del ciclo è necessario per stampare il
separatore <code class="language-plaintext highlighter-rouge">,</code> <strong>solo</strong> quando c’è almeno un altro elemento
dell’insieme da stampare</li>
</ul>

<h1 id="esercizi">Esercizi</h1>

<ol>
  <li>Aggiungere alla classe <code class="language-plaintext highlighter-rouge">Set</code> un metodo <code class="language-plaintext highlighter-rouge">empty</code> che restituisca
<code class="language-plaintext highlighter-rouge">true</code> se l’insieme è vuoto, <code class="language-plaintext highlighter-rouge">false</code> altrimenti.</li>
  <li>Aggiungere alla classe <code class="language-plaintext highlighter-rouge">Set</code> un metodo <code class="language-plaintext highlighter-rouge">elements</code> che restituisca
il vettore ordinato contenente tutti gli elementi di un insieme.</li>
  <li>Aggiungere alla classe <code class="language-plaintext highlighter-rouge">Set</code> i metodi <code class="language-plaintext highlighter-rouge">minimum</code> e <code class="language-plaintext highlighter-rouge">maximum</code> che
restituiscano, rispettivamente, l’elemento più piccolo e più
grande di un insieme non vuoto.</li>
  <li>Aggiungere alla classe <code class="language-plaintext highlighter-rouge">Set</code> i metodi <code class="language-plaintext highlighter-rouge">_union</code>, <code class="language-plaintext highlighter-rouge">intersection</code> e
<code class="language-plaintext highlighter-rouge">difference</code> che calcolino rispettivamente l’unione, intersezione
e la differenza di insiemi. Fare in modo che tali metodi non
modifichino gli insiemi coinvolti nell’operazione. <strong>Nota</strong>: il
metodo di unione non può chiamarsi <code class="language-plaintext highlighter-rouge">union</code> perché questa è una
parola riservata del linguaggio.</li>
  <li>Aggiungere alla classe <code class="language-plaintext highlighter-rouge">Set</code> un metodo <code class="language-plaintext highlighter-rouge">overlap(const Set&amp;)</code> che
restituisca <code class="language-plaintext highlighter-rouge">true</code> se due insiemi hanno un’intersezione non
vuota, <code class="language-plaintext highlighter-rouge">false</code> altrimenti. Se possibile, scrivere <code class="language-plaintext highlighter-rouge">overlap</code> in
modo tale che il costo dell’esecuzione del metodo sia, nel caso
pessimo, proporzionale alla somma delle dimensioni dei due
insiemi.</li>
</ol>

      </div>
    </div>
    <script type="text/javascript" src="../js/slider.js"></script>
    <script>
      (function() {
	  if (window.location.search != "?handout") {
	      document.write('<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/reveal.js@3.9.2/js/reveal.min.js"><\/script>');
	  }
      })();
    </script>
    <script>
      initialize_slider();
      if (window.location.search != "?handout") {
	  // Setup Reveal
	  Reveal.initialize({
	      controls:    false,  // No control arrows
	      slideNumber: 'c/t',  // Print slide number
	      center:      false,  // Do not align slide vertically
	      progress:    false,  // Do not display progress bar
	      hash:        true,   // Store slide number in URL
	      transition:  'none', // Transition mode
	      transitionSpeed: 'fast',
	      width:       848,
	      height:      600,
	      margin:      0,
	      pdfSeparateFragments: false,
	  });
      }
    </script>
    <script type="text/javascript" src="../js/mathjax.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  </body>
</html>
